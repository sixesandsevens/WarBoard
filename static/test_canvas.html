<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>WarBoard Canvas Test</title>
  <style>
    body { margin:0; font-family: system-ui, sans-serif; background:#111; color:#eee; }
    #top {
      padding: 10px;
      position: relative;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      background:#0f0f0f; border-bottom:1px solid #222;
    }
    .top-left, .top-right {
      display:flex;
      align-items:center;
      gap:8px;
      min-width: 0;
    }
    .top-center {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    input, select { padding: 6px; }
    button { padding: 6px 10px; cursor:pointer; }
    label { display:flex; gap:6px; align-items:center; }
    #wrap { position: relative; width: 100vw; height: calc(100vh - 64px); }
    canvas { display:block; width:100%; height:100%; background:#222; }
    #log {
      position:absolute; left:10px; bottom:10px;
      width:min(560px, calc(100vw - 20px));
      max-height: 200px;
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.12);
      display: flex;
      flex-direction: column;
      font-family: ui-monospace, monospace;
      font-size: 12px;
      z-index: 2;
    }
    #logHeader {
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 6px 8px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      font-size: 11px;
      opacity: 0.9;
      user-select: none;
    }
    #logText {
      padding: 8px;
      overflow: auto;
      white-space: pre-wrap;
      max-height: 150px;
    }
    #log.collapsed #logText { display: none; }
    #log.collapsed { max-height: none; width: 230px; }
    #logToggle {
      padding: 2px 8px;
      font-size: 11px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.06);
      color: #ddd;
    }
    #hint {
      position:absolute; right:10px; bottom:10px;
      background: rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 8px;
      font-size: 12px;
      max-width: 420px;
      line-height: 1.35;
      z-index: 2;
    }
    .pill { display:inline-block; padding:2px 6px; border-radius:999px; border:1px solid rgba(255,255,255,0.18); }
    .drawer-toggle { padding: 6px 10px; font-size: 18px; }
    .drawer {
      position: fixed;
      top: 64px;
      left: 0;
      width: 320px;
      height: calc(100% - 64px);
      background: #1e1e1e;
      color: #eee;
      box-shadow: 2px 0 10px rgba(0,0,0,0.4);
      z-index: 999;
      display: flex;
      flex-direction: column;
      transform: translateX(0);
      transition: transform 0.2s ease;
    }
    .drawer.hidden {
      transform: translateX(-100%);
      display: block;
    }
    .drawer-header {
      display: flex;
      justify-content: space-between;
      padding: 10px;
      background: #2a2a2a;
      font-weight: bold;
    }
    .drawer-tabs {
      display: flex;
      flex-wrap: wrap;
      border-bottom: 1px solid #444;
    }
    .drawer-tabs button {
      flex: 1;
      padding: 6px;
      background: #2a2a2a;
      border: none;
      color: #ccc;
      cursor: pointer;
    }
    .drawer-tabs button.active {
      background: #444;
      color: white;
    }
    .drawer-content {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }
    .drawer-panel {
      display: none;
    }
    .drawer-panel.active {
      display: block;
    }
    .ctx {
      position: fixed;
      z-index: 2000;
      min-width: 220px;
      background: #1f1f1f;
      color: #eee;
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.45);
      padding: 6px;
      font-family: system-ui, sans-serif;
      user-select: none;
    }
    .ctx.hidden { display: none; }
    .ctx-title {
      font-size: 12px;
      opacity: 0.75;
      padding: 6px 8px;
    }
    .ctx-item {
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      line-height: 1.1;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .ctx-item:hover { background: rgba(255,255,255,0.10); }
    .ctx-item.danger:hover { background: rgba(255,0,0,0.15); }
    .ctx-sep {
      height: 1px;
      margin: 6px 6px;
      background: rgba(255,255,255,0.10);
    }
    .ctx-sub { min-width: 240px; }
    .tool-strip {
      display: inline-flex;
      gap: 4px;
      align-items: center;
      padding: 2px 4px;
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 999px;
      background: rgba(255,255,255,0.04);
    }
    .tool-btn {
      padding: 5px 8px;
      font-size: 13px;
      border: 1px solid transparent;
      border-radius: 999px;
      background: rgba(255,255,255,0.03);
      color: #ddd;
    }
    .tool-btn.active {
      background: rgba(0,209,255,0.16);
      border-color: rgba(0,209,255,0.55);
      color: #fff;
    }
    .top-action-btn {
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid transparent;
      background: rgba(255,255,255,0.03);
      color: #ddd;
    }
    .top-action-btn:hover {
      background: rgba(255,255,255,0.10);
    }
    .top-action-btn.active {
      background: rgba(0,209,255,0.16);
      border-color: rgba(0,209,255,0.55);
      color: #fff;
    }
    .tool-activate {
      animation: toolPulse 120ms ease;
    }
    @keyframes toolPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.06); }
      100% { transform: scale(1); }
    }
    .ui-tooltip {
      position: fixed;
      z-index: 3500;
      padding: 6px 8px;
      border-radius: 8px;
      background: rgba(16,16,16,0.96);
      border: 1px solid rgba(255,255,255,0.12);
      color: #eee;
      font-size: 12px;
      pointer-events: none;
      white-space: nowrap;
    }
    .size-strip {
      display: inline-flex;
      gap: 4px;
      align-items: center;
      padding: 2px 4px;
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 999px;
      background: rgba(255,255,255,0.04);
      font-size: 12px;
    }
    .session-pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background:#151515;
      cursor:pointer;
      font-size:13px;
    }
    .session-pill.ok{ border-color: rgba(0,255,120,0.25); }
    .session-pill.bad{ border-color: rgba(255,80,80,0.25); }
    .session-resync {
      font-size: 11px;
      opacity: 0.85;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
    }
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      z-index: 3000;
    }
    .modal {
      position: fixed;
      top: 70px;
      left: 12px;
      width: 320px;
      background: #1f1f1f;
      color: #eee;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      box-shadow: 0 18px 50px rgba(0,0,0,0.55);
      z-index: 3001;
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .modal-title { font-weight: 700; }
    .modal-close {
      border: none;
      background: transparent;
      color: #bbb;
      font-size: 16px;
      cursor: pointer;
    }
    .modal-body { padding: 12px; }
    .field { margin-bottom: 10px; }
    .field label {
      display: block;
      font-size: 12px;
      opacity: 0.8;
      margin-bottom: 4px;
    }
    .field input {
      width: 100%;
      box-sizing: border-box;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: #141414;
      color: #eee;
    }
    .hint { font-size: 12px; opacity: 0.65; margin-top: 4px; }
    .modal-actions { display: flex; gap: 8px; margin-top: 12px; }
    button.primary {
      padding: 8px 10px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
    }
    button.ghost {
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: transparent;
      color: #ddd;
      cursor: pointer;
    }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div id="top">
    <div class="top-left">
      <button id="drawerToggle" class="drawer-toggle">‚ò∞</button>
      <div id="sessionPill" class="session-pill bad">‚óã Disconnected</div>
      <div id="sessionResyncBadge" class="session-resync hidden">Resyncing...</div>
    </div>
    <div class="top-center">
      <div class="tool-strip">
        <button id="toolBtnMove" class="tool-btn" data-tool="move" data-tip="Move tokens">üñê Move</button>
        <button id="toolBtnPen" class="tool-btn" data-tool="pen" data-tip="Draw freehand">‚úèÔ∏è Pen</button>
        <button id="toolBtnShape" class="tool-btn" data-tool="shape" data-tip="Draw shapes">‚¨õ Shape</button>
        <button id="toolBtnText" class="tool-btn" data-tool="text" data-tip="Place text label">üî§ Text</button>
        <button id="toolBtnErase" class="tool-btn" data-tool="eraser" data-tip="Erase drawings">üßΩ Erase</button>
        <button id="toolBtnRuler" class="tool-btn" data-tool="ruler" data-tip="Measure distance">üìè Ruler</button>
      </div>
      <button id="spawn" class="top-action-btn" data-tip="Place new token">Spawn Token</button>
      <span id="sizePresetGroup" class="size-strip">
        Size
        <button id="sizePresetS" class="top-action-btn">S</button>
        <button id="sizePresetM" class="top-action-btn">M</button>
        <button id="sizePresetL" class="top-action-btn">L</button>
        <button id="sizePresetH" class="top-action-btn">Huge</button>
      </span>
      <button id="undo" class="top-action-btn" data-tip="Undo last action">Undo</button>
      <button id="redo" class="top-action-btn" data-tip="Redo last undone action">Redo</button>
    </div>
    <label style="display:none;">Room <input id="room" value="demo"></label>
    <label style="display:none;">Client ID <input id="cid" value="chris"></label>
    <button id="connect" style="display:none;">Connect</button>
    <button id="gmPanelBtn">GM Panel</button>
    <button id="roomsPanelBtn">Rooms</button>
    <button id="libraryPanelBtn">Token Library</button>

    <label><input type="checkbox" id="allowPlayersMove"> Players move assigned</label>
    <label><input type="checkbox" id="allowAllMove"> Everyone moves everything</label>
    <label><input type="checkbox" id="lockdown"> Lockdown</label>

    <label>BG URL <input id="bgUrl" placeholder="https://..."></label>
    <button id="setBg">Set BG</button>
    <label><input type="checkbox" id="terrainBg"> Terrain BG</label>
    <label>Biome
      <select id="terrainStyle">
        <option value="grassland">Grassland</option>
        <option value="dirt">Dirt/Road</option>
        <option value="snow">Snow</option>
        <option value="desert">Desert</option>
      </select>
    </label>
    <button id="regenTerrain">Regenerate Terrain</button>
    <span id="terrainBadge" class="pill" style="display:none; opacity:.9;"></span>

    <label style="display:none;">Tool
      <select id="tool">
        <option value="move">Move</option>
        <option value="pen">Pen</option>
        <option value="eraser">Eraser (GM)</option>
        <option value="rect">Rect</option>
        <option value="circle">Circle</option>
        <option value="line">Line</option>
        <option value="text">Text</option>
        <option value="ruler">Ruler</option>
      </select>
    </label>

    <label style="display:none;">Color <input id="color" type="color" value="#ffffff"></label>
    <label style="display:none;">Size <input id="size" type="number" value="3" min="1" max="30" style="width:70px"></label>
    <label>ft/sq <input id="feetPerSq" type="number" value="5" min="1" max="100" style="width:70px"></label>

    <label><input type="checkbox" id="snap" checked> Snap</label>
    <label>Grid <input id="grid" value="50" style="width:70px"></label>
    <label><input type="checkbox" id="showGrid" checked> Grid</label>

    <label><input type="checkbox" id="layerGrid" checked> Layer Grid</label>
    <label><input type="checkbox" id="layerDraw" checked> Layer Drawings</label>
    <label><input type="checkbox" id="layerShapes" checked> Layer Shapes</label>
    <label><input type="checkbox" id="layerTokens" checked> Layer Tokens</label>
  </div>

  <div id="wrap">
    <div id="sessionModalBackdrop" class="modal-backdrop hidden"></div>
    <div id="sessionModal" class="modal hidden" role="dialog" aria-modal="true" aria-label="Session">
      <div class="modal-header">
        <div id="sessionModalTitle" class="modal-title">Disconnected - Single Session Mode</div>
        <button id="sessionModalClose" class="modal-close">‚úï</button>
      </div>
      <div class="modal-body">
        <div id="sessionStatusText" class="hint" style="margin-bottom:10px;">
          Everything works locally. Log in to host or join a shared room.
        </div>
        <div id="sessionAuthBox">
          <div class="field">
            <label>Username</label>
            <input id="sessionAuthUser" type="text" autocomplete="username" />
          </div>
          <div class="field">
            <label>Password</label>
            <input id="sessionAuthPass" type="password" autocomplete="current-password" />
          </div>
          <div class="modal-actions">
            <button id="sessionLoginBtn" class="primary">Log In</button>
            <button id="sessionRegisterBtn" class="ghost">Register</button>
          </div>
        </div>
        <div id="sessionAccountBox" class="hidden">
          <div id="sessionWhoami" class="hint"></div>
          <div class="modal-actions">
            <button id="sessionOpenLobbyBtn" class="primary">Open Account Panel</button>
            <button id="sessionLogoutBtn" class="ghost">Log Out</button>
          </div>
        </div>
        <hr style="border:0; border-top:1px solid rgba(255,255,255,0.12); margin:12px 0;">
        <div class="field">
          <label>Room (optional online room id)</label>
          <input id="sessionRoom" type="text" autocomplete="off" />
        </div>
        <div class="field">
          <label>Client ID</label>
          <input id="sessionClientId" type="text" autocomplete="off" />
        </div>
        <div class="modal-actions">
          <button id="sessionConnectBtn" class="primary">Connect Room</button>
          <button id="sessionDisconnectBtn" class="ghost hidden">Disconnect</button>
        </div>
      </div>
    </div>
    <div id="drawer" class="drawer hidden">
      <div class="drawer-header">
        <span>WarBoard</span>
        <button id="drawerClose">‚úï</button>
      </div>

      <div class="drawer-tabs">
        <button data-tab="tokens" class="tab-btn active">Tokens</button>
        <button data-tab="rooms" class="tab-btn">Rooms</button>
        <button data-tab="scene" class="tab-btn">Scene</button>
        <button data-tab="players" class="tab-btn">Players</button>
        <button data-tab="settings" class="tab-btn">Settings</button>
      </div>

      <div class="drawer-content">
        <div id="tab-tokens" class="drawer-panel active"></div>
        <div id="tab-rooms" class="drawer-panel"></div>
        <div id="tab-scene" class="drawer-panel"></div>
        <div id="tab-players" class="drawer-panel"></div>
        <div id="tab-settings" class="drawer-panel"></div>
      </div>
    </div>
    <canvas id="c"></canvas>
    <div id="tokenMenu" style="
      position:absolute;
      min-width: 180px;
      background: rgba(0,0,0,0.92);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 8px;
      padding: 6px;
      display:none;
      z-index: 4;
    ">
      <button id="tokenMenuRename" style="display:block; width:100%; text-align:left; margin:2px 0;">Rename</button>
      <button id="tokenMenuResize" style="display:block; width:100%; text-align:left; margin:2px 0;">Resize</button>
      <button id="tokenMenuAssign" style="display:block; width:100%; text-align:left; margin:2px 0;">Assign owner</button>
      <button id="tokenMenuLock" style="display:block; width:100%; text-align:left; margin:2px 0;">Lock / Unlock</button>
      <div style="height:1px; margin:6px 0; background:rgba(255,255,255,0.12);"></div>
      <button id="tokenMenuBadgeDowned" style="display:block; width:100%; text-align:left; margin:2px 0;">Downed</button>
      <button id="tokenMenuBadgePoisoned" style="display:block; width:100%; text-align:left; margin:2px 0;">Poisoned</button>
      <button id="tokenMenuBadgeStunned" style="display:block; width:100%; text-align:left; margin:2px 0;">Stunned</button>
      <button id="tokenMenuBadgeBurning" style="display:block; width:100%; text-align:left; margin:2px 0;">Burning</button>
      <button id="tokenMenuBadgeBleeding" style="display:block; width:100%; text-align:left; margin:2px 0;">Bleeding</button>
      <button id="tokenMenuBadgeProne" style="display:block; width:100%; text-align:left; margin:2px 0;">Prone</button>
      <button id="tokenMenuBadgeClear" style="display:block; width:100%; text-align:left; margin:2px 0;">Clear badges</button>
      <button id="tokenMenuDelete" style="display:block; width:100%; text-align:left; margin:2px 0; color:#ffb3b3;">Delete</button>
    </div>
    <div id="mapCtx" class="ctx hidden" role="menu" aria-label="Map menu">
      <div class="ctx-title">Map</div>
      <div class="ctx-item" data-action="spawn_default" data-gm="1">‚ûï Spawn token</div>
      <div class="ctx-sep"></div>
      <div class="ctx-item has-sub" data-sub="bg" data-gm="1">üñº Background ‚ñ∏</div>
      <div class="ctx-item has-sub" data-sub="layers" data-gm="1">üßÖ Layers ‚ñ∏</div>
      <div class="ctx-sep"></div>
      <div class="ctx-item has-sub" data-sub="clear" data-gm="1">üßπ Clear ‚ñ∏</div>
      <div class="ctx-item" data-action="save_snapshot" data-gm="1">üíæ Save snapshot</div>
      <div class="ctx-sep"></div>
      <div class="ctx-item" data-action="open_tokens">üìö Token Library</div>
      <div class="ctx-item" data-action="open_rooms">üè† Rooms</div>
      <div class="ctx-item" data-action="open_scene">üéõ Scene</div>
    </div>
    <div id="mapCtx-bg" class="ctx hidden ctx-sub" role="menu" aria-label="Background menu">
      <div class="ctx-title">Background</div>
      <div class="ctx-item" data-action="bg_solid" data-gm="1">Solid (default)</div>
      <div class="ctx-item" data-action="bg_url" data-gm="1">Set URL...</div>
      <div class="ctx-item" data-action="bg_terrain" data-gm="1">Terrain</div>
      <div class="ctx-item" data-action="bg_terrain_regen" data-gm="1">Regenerate terrain</div>
    </div>
    <div id="mapCtx-layers" class="ctx hidden ctx-sub" role="menu" aria-label="Layers menu">
      <div class="ctx-title">Layers</div>
      <div class="ctx-item" data-action="toggle_layer_grid" data-gm="1">Toggle Grid</div>
      <div class="ctx-item" data-action="toggle_layer_drawings" data-gm="1">Toggle Drawings</div>
      <div class="ctx-item" data-action="toggle_layer_shapes" data-gm="1">Toggle Shapes</div>
      <div class="ctx-item" data-action="toggle_layer_tokens" data-gm="1">Toggle Tokens</div>
    </div>
    <div id="mapCtx-clear" class="ctx hidden ctx-sub" role="menu" aria-label="Clear menu">
      <div class="ctx-title">Clear</div>
      <div class="ctx-item danger" data-action="clear_drawings" data-gm="1">Clear drawings</div>
      <div class="ctx-item danger" data-action="clear_shapes" data-gm="1">Clear shapes</div>
      <div class="ctx-item danger" data-action="clear_tokens" data-gm="1">Clear tokens</div>
    </div>
    <div id="penCtx" class="ctx hidden" role="menu" aria-label="Pen menu">
      <div class="ctx-title">Pen</div>
      <div class="ctx-item" data-action="pen_size_2">Size 2</div>
      <div class="ctx-item" data-action="pen_size_4">Size 4</div>
      <div class="ctx-item" data-action="pen_size_8">Size 8</div>
      <div class="ctx-item" data-action="pen_size_custom">Custom size...</div>
      <div class="ctx-sep"></div>
      <div class="ctx-item" data-action="pen_color_white">Color White</div>
      <div class="ctx-item" data-action="pen_color_red">Color Red</div>
      <div class="ctx-item" data-action="pen_color_green">Color Green</div>
      <div class="ctx-item" data-action="pen_color_blue">Color Blue</div>
      <div class="ctx-item" data-action="pen_color_custom">Custom color...</div>
    </div>
    <div id="shapeCtx" class="ctx hidden" role="menu" aria-label="Shape menu">
      <div class="ctx-title">Shape</div>
      <div class="ctx-item" data-action="shape_tool_rect">Rect Tool</div>
      <div class="ctx-item" data-action="shape_tool_circle">Circle Tool</div>
      <div class="ctx-item" data-action="shape_tool_line">Line Tool</div>
      <div class="ctx-sep"></div>
      <div class="ctx-item" data-action="shape_size_2">Stroke 2</div>
      <div class="ctx-item" data-action="shape_size_4">Stroke 4</div>
      <div class="ctx-item" data-action="shape_size_8">Stroke 8</div>
      <div class="ctx-item" data-action="shape_size_custom">Custom size...</div>
      <div class="ctx-sep"></div>
      <div class="ctx-item" data-action="shape_color_custom">Custom color...</div>
      <div class="ctx-item" data-action="shape_toggle_snap">Toggle Snap</div>
    </div>
    <div id="rulerCtx" class="ctx hidden" role="menu" aria-label="Ruler menu">
      <div class="ctx-title">Ruler</div>
      <div class="ctx-item" data-action="ruler_feet_5">Set 5 ft/sq</div>
      <div class="ctx-item" data-action="ruler_feet_10">Set 10 ft/sq</div>
      <div class="ctx-item" data-action="ruler_feet_15">Set 15 ft/sq</div>
      <div class="ctx-sep"></div>
      <div class="ctx-item" data-action="ruler_toggle_snap">Toggle Snap</div>
      <div class="ctx-item" data-action="ruler_clear">Clear ruler</div>
    </div>
    <div id="toolColorPanel" class="ctx hidden" role="dialog" aria-label="Tool color">
      <div id="toolColorTitle" class="ctx-title">Color</div>
      <div style="padding:8px 10px;">
        <input id="toolColorPicker" type="color" value="#ffffff" style="width:100%; height:36px; border:none; background:transparent; padding:0;">
      </div>
    </div>
    <div id="toolSizePanel" class="ctx hidden" role="dialog" aria-label="Tool size">
      <div id="toolSizeTitle" class="ctx-title">Size</div>
      <div style="padding:8px 10px; display:flex; flex-direction:column; gap:8px;">
        <input id="toolSizeSlider" type="range" min="1" max="30" step="1" value="3">
        <div id="toolSizeValue" style="font-size:12px; opacity:.85;">3</div>
      </div>
    </div>
    <div id="uiTooltip" class="ui-tooltip hidden"></div>
    <div id="roomsPanel" style="
      position:absolute; top:10px; left:10px;
      width:min(460px, calc(100vw - 20px));
      max-height: calc(100vh - 120px);
      overflow:auto;
      background: rgba(0,0,0,0.78);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 10px;
      display:none;
      z-index: 3;
    ">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <b>Rooms</b>
        <button id="roomsPanelClose">Close</button>
      </div>
      <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap; align-items:center;">
        <input id="newRoomName" placeholder="Room name" style="flex:1; min-width:150px;">
        <input id="newRoomId" placeholder="optional id" style="width:120px;">
        <button id="createRoomBtn">Create</button>
        <button id="refreshRoomsBtn">Refresh</button>
      </div>
      <div id="roomsList" style="margin-top:8px; font-size:12px;"></div>

      <hr style="border:0; border-top:1px solid rgba(255,255,255,0.12); margin:10px 0;">
      <div style="display:flex; gap:6px; align-items:center; flex-wrap:wrap;">
        <b>Snapshots for</b>
        <code id="snapshotRoomLabel">demo</code>
      </div>
      <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap; align-items:center;">
        <input id="snapshotLabelInput" placeholder="Save Point label" style="flex:1; min-width:180px;">
        <button id="saveSnapshotBtn">Save Point</button>
        <button id="refreshSnapshotsBtn">Refresh</button>
      </div>
      <div id="snapshotsList" style="margin-top:8px; font-size:12px;"></div>
    </div>
    <div id="libraryPanel" style="
      position:absolute; top:10px; left:10px;
      width:min(560px, calc(100vw - 20px));
      max-height: calc(100vh - 120px);
      overflow:auto;
      background: rgba(0,0,0,0.82);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 10px;
      display:none;
      z-index: 3;
    ">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <b>Token Library</b>
        <button id="libraryPanelClose">Close</button>
      </div>
      <div style="margin-top:8px; display:flex; gap:6px; align-items:center; flex-wrap:wrap;">
        <label>Pack
          <select id="packSelect" style="min-width:200px;"></select>
        </label>
        <input id="packSearch" placeholder="Search tokens..." style="flex:1; min-width:180px;">
        <button id="refreshPacksBtn">Refresh</button>
      </div>
      <div id="packGrid" style="
        margin-top:8px;
        display:grid;
        grid-template-columns: repeat(auto-fill, minmax(96px, 1fr));
        gap:8px;
      "></div>
    </div>
    <div id="gmPanel" style="
      position:absolute; top:10px; right:10px;
      width:min(480px, calc(100vw - 20px));
      max-height: calc(100vh - 120px);
      overflow:auto;
      background: rgba(0,0,0,0.78);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 10px;
      display:none;
      z-index: 3;
    ">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <b>GM Panel</b>
        <button id="gmPanelClose">Close</button>
      </div>

      <div style="margin-top:10px;">
        <div style="opacity:.9; margin-bottom:6px;">Connected players</div>
        <div id="playerList" style="font-family: ui-monospace, monospace; font-size:12px;"></div>
      </div>

      <hr style="border:0; border-top:1px solid rgba(255,255,255,0.12); margin:10px 0;">
      <div>
        <div style="opacity:.9; margin-bottom:6px;">Tokens (owner + lock)</div>
        <div id="tokenList"></div>
      </div>

      <hr style="border:0; border-top:1px solid rgba(255,255,255,0.12); margin:10px 0;">
      <div>
        <div style="opacity:.9; margin-bottom:6px;">Strokes (lock)</div>
        <div id="strokeList"></div>
      </div>

      <hr style="border:0; border-top:1px solid rgba(255,255,255,0.12); margin:10px 0;">
      <div>
        <div style="opacity:.9; margin-bottom:6px;">Shapes (lock)</div>
        <div id="shapeList"></div>
      </div>
    </div>

    <div id="log">
      <div id="logHeader">
        <span>Activity Log</span>
        <button id="logToggle" type="button">Minimize</button>
      </div>
      <div id="logText"></div>
    </div>
    <div id="hint">
      <div><span class="pill">Left-drag</span> act with tool</div>
      <div><span class="pill">Right-drag</span> pan</div>
      <div><span class="pill">Wheel</span> zoom</div>
      <div><span class="pill">Delete</span> delete selected token (GM)</div>
      <div style="opacity:.85;margin-top:6px">
        Layer visibility and background are server-synced room settings.
      </div>
    </div>
  </div>

<script>
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const logEl = document.getElementById("logText");
  const logWrapEl = document.getElementById("log");
  const logToggleEl = document.getElementById("logToggle");

  const roomEl = document.getElementById("room");
  const cidEl = document.getElementById("cid");
  const OFFLINE_STATE_KEY = "warboard_offline_state_v1";
  let online = false;
  let me = null;

  // If launched from the lobby, auto-fill room from query (?room=xxxx)
  try {
    const qp = new URLSearchParams(location.search);
    const qroom = qp.get("room");
    if (qroom) roomEl.value = qroom;
  } catch(e) {}
  const allowPlayersMoveEl = document.getElementById("allowPlayersMove");
  const allowAllMoveEl = document.getElementById("allowAllMove");
  const lockdownEl = document.getElementById("lockdown");
  const bgUrlEl = document.getElementById("bgUrl");
  const terrainBgEl = document.getElementById("terrainBg");
  const terrainStyleEl = document.getElementById("terrainStyle");
  const regenTerrainEl = document.getElementById("regenTerrain");
  const terrainBadgeEl = document.getElementById("terrainBadge");

  const layerGridEl = document.getElementById("layerGrid");
  const layerDrawEl = document.getElementById("layerDraw");
  const layerShapesEl = document.getElementById("layerShapes");
  const layerTokensEl = document.getElementById("layerTokens");

  const gmPanel = document.getElementById("gmPanel");
  const roomsPanel = document.getElementById("roomsPanel");
  const libraryPanel = document.getElementById("libraryPanel");
  const tokenMenuEl = document.getElementById("tokenMenu");
  const drawer = document.getElementById("drawer");
  const drawerToggle = document.getElementById("drawerToggle");
  const drawerClose = document.getElementById("drawerClose");
  const mapCtx = document.getElementById("mapCtx");
  const mapCtxBg = document.getElementById("mapCtx-bg");
  const mapCtxLayers = document.getElementById("mapCtx-layers");
  const mapCtxClear = document.getElementById("mapCtx-clear");
  const penCtx = document.getElementById("penCtx");
  const shapeCtx = document.getElementById("shapeCtx");
  const rulerCtx = document.getElementById("rulerCtx");
  const toolColorPanel = document.getElementById("toolColorPanel");
  const toolColorTitle = document.getElementById("toolColorTitle");
  const toolColorPicker = document.getElementById("toolColorPicker");
  const toolSizePanel = document.getElementById("toolSizePanel");
  const toolSizeTitle = document.getElementById("toolSizeTitle");
  const toolSizeSlider = document.getElementById("toolSizeSlider");
  const toolSizeValue = document.getElementById("toolSizeValue");
  const uiTooltip = document.getElementById("uiTooltip");
  const allCtxMenus = [mapCtx, mapCtxBg, mapCtxLayers, mapCtxClear, penCtx, shapeCtx, rulerCtx];
  const playerListEl = document.getElementById("playerList");
  const tokenListEl = document.getElementById("tokenList");
  const strokeListEl = document.getElementById("strokeList");
  const shapeListEl = document.getElementById("shapeList");
  const roomsListEl = document.getElementById("roomsList");
  const snapshotsListEl = document.getElementById("snapshotsList");
  const snapshotRoomLabelEl = document.getElementById("snapshotRoomLabel");
  const newRoomNameEl = document.getElementById("newRoomName");
  const newRoomIdEl = document.getElementById("newRoomId");
  const snapshotLabelInputEl = document.getElementById("snapshotLabelInput");
  const packSelectEl = document.getElementById("packSelect");
  const packSearchEl = document.getElementById("packSearch");
  const packGridEl = document.getElementById("packGrid");

  const toolEl = document.getElementById("tool");
  const toolBtnMove = document.getElementById("toolBtnMove");
  const toolBtnPen = document.getElementById("toolBtnPen");
  const toolBtnShape = document.getElementById("toolBtnShape");
  const toolBtnText = document.getElementById("toolBtnText");
  const toolBtnErase = document.getElementById("toolBtnErase");
  const toolBtnRuler = document.getElementById("toolBtnRuler");
  const sessionPill = document.getElementById("sessionPill");
  const sessionResyncBadge = document.getElementById("sessionResyncBadge");
  const sessionModal = document.getElementById("sessionModal");
  const sessionModalBackdrop = document.getElementById("sessionModalBackdrop");
  const sessionModalClose = document.getElementById("sessionModalClose");
  const sessionModalTitleEl = document.getElementById("sessionModalTitle");
  const sessionStatusTextEl = document.getElementById("sessionStatusText");
  const sessionAuthBoxEl = document.getElementById("sessionAuthBox");
  const sessionAccountBoxEl = document.getElementById("sessionAccountBox");
  const sessionAuthUserEl = document.getElementById("sessionAuthUser");
  const sessionAuthPassEl = document.getElementById("sessionAuthPass");
  const sessionLoginBtn = document.getElementById("sessionLoginBtn");
  const sessionRegisterBtn = document.getElementById("sessionRegisterBtn");
  const sessionWhoamiEl = document.getElementById("sessionWhoami");
  const sessionOpenLobbyBtn = document.getElementById("sessionOpenLobbyBtn");
  const sessionLogoutBtn = document.getElementById("sessionLogoutBtn");
  const sessionRoomEl = document.getElementById("sessionRoom");
  const sessionClientEl = document.getElementById("sessionClientId");
  const sessionConnectBtn = document.getElementById("sessionConnectBtn");
  const sessionDisconnectBtn = document.getElementById("sessionDisconnectBtn");
  const colorEl = document.getElementById("color");
  const sizeEl = document.getElementById("size");
  const feetPerSqEl = document.getElementById("feetPerSq");
  const snapEl = document.getElementById("snap");
  const gridEl = document.getElementById("grid");
  const showGridEl = document.getElementById("showGrid");
  const sizePresetButtons = {
    0.5: document.getElementById("sizePresetS"),
    1.0: document.getElementById("sizePresetM"),
    2.0: document.getElementById("sizePresetL"),
    3.0: document.getElementById("sizePresetH"),
  };
  const TOKEN_BADGES = [
    { id: "downed", label: "Downed", color: "#1f1f1f", glyph: "‚úñ", menuId: "tokenMenuBadgeDowned" },
    { id: "poisoned", label: "Poisoned", color: "#2f8f2f", glyph: "P", menuId: "tokenMenuBadgePoisoned" },
    { id: "stunned", label: "Stunned", color: "#d4b000", glyph: "‚òÖ", menuId: "tokenMenuBadgeStunned" },
    { id: "burning", label: "Burning", color: "#d46a00", glyph: "F", menuId: "tokenMenuBadgeBurning" },
    { id: "bleeding", label: "Bleeding", color: "#b00020", glyph: "B", menuId: "tokenMenuBadgeBleeding" },
    { id: "prone", label: "Prone", color: "#5a5a5a", glyph: "‚Ü∑", menuId: "tokenMenuBadgeProne" },
  ];
  const TOKEN_BADGE_BY_ID = new Map(TOKEN_BADGES.map((b) => [b.id, b]));
  const TOKEN_BADGE_IDS = new Set(TOKEN_BADGES.map((b) => b.id));

  function log(line) {
    if (!logEl) return;
    logEl.textContent += line + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  }

  function setLogCollapsed(collapsed) {
    if (logWrapEl) logWrapEl.classList.toggle("collapsed", !!collapsed);
    if (logToggleEl) logToggleEl.textContent = collapsed ? "Maximize" : "Minimize";
  }

  function apiUrl(path, includeGm = false) {
    const url = new URL(path, window.location.origin);
    return url.toString();
  }

  async function apiGet(path, includeGm = false) {
    const res = await fetch(apiUrl(path, includeGm));
    if (!res.ok) throw new Error(await res.text());
    return res.json();
  }

  async function apiPost(path, body = {}, includeGm = false) {
    const res = await fetch(apiUrl(path, includeGm), {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(body),
    });
    if (!res.ok) throw new Error(await res.text());
    return res.json();
  }

  async function apiPatch(path, body = {}, includeGm = false) {
    const res = await fetch(apiUrl(path, includeGm), {
      method: "PATCH",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(body),
    });
    if (!res.ok) throw new Error(await res.text());
    return res.json();
  }

  function setAuthIdentity(user) {
    me = user && user.username ? user : null;
    if (me) {
      cidEl.value = me.username;
      cidEl.disabled = true;
      cidEl.title = "Logged in as " + me.username;
      sessionClientEl.value = me.username;
      sessionClientEl.disabled = true;
    } else {
      cidEl.disabled = false;
      cidEl.title = "";
      sessionClientEl.disabled = false;
    }
  }

  async function loadMe() {
    try {
      const res = await fetch("/api/me");
      if (!res.ok) {
        setAuthIdentity(null);
        return null;
      }
      const user = await res.json();
      setAuthIdentity(user);
      return user;
    } catch (e) {
      setAuthIdentity(null);
      return null;
    }
  }

  function tokenImage(url) {
    if (!url) return null;
    if (tokenImageCache.has(url)) return tokenImageCache.get(url);
    const img = new Image();
    img.decoding = "async";
    img.loading = "eager";
    img.onload = () => requestRender();
    img.onerror = () => requestRender();
    img.src = url;
    tokenImageCache.set(url, img);
    return img;
  }

  function drawTokenImageClippedCircle(t, s, r) {
    const img = tokenImage(t.image_url || "");
    if (!img || !img.complete || img.naturalWidth <= 0 || img.naturalHeight <= 0) return false;
    const iw = img.naturalWidth;
    const ih = img.naturalHeight;
    const scale = Math.max((2 * r) / iw, (2 * r) / ih);
    const dw = iw * scale;
    const dh = ih * scale;

    ctx.save();
    ctx.beginPath();
    ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
    ctx.clip();
    ctx.drawImage(img, s.x - dw / 2, s.y - dh / 2, dw, dh);
    ctx.restore();
    return true;
  }

  function sanitizePackToken(token, packId) {
    const id = String(token?.id || "").trim();
    const name = String(token?.name || id || "Token").trim() || "Token";
    const file = String(token?.file || "").trim();
    const tags = Array.isArray(token?.tags) ? token.tags.map((x) => String(x).trim().toLowerCase()).filter(Boolean) : [];
    if (!id || !file) return null;
    const safePath = file
      .replace(/^\/+/, "")
      .split("/")
      .map((seg) => encodeURIComponent(seg))
      .join("/");
    return {
      id,
      name,
      file,
      tags,
      image_url: `/packs/${encodeURIComponent(packId)}/${safePath}`,
    };
  }

  function escapeHtml(s) {
    return String(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll("\"", "&quot;")
      .replaceAll("'", "&#39;");
  }

  function activateDrawerTab(tab, openDrawer = true) {
    const tabId = String(tab || "tokens");
    document.querySelectorAll(".tab-btn").forEach((b) => {
      b.classList.toggle("active", b.dataset.tab === tabId);
    });
    document.querySelectorAll(".drawer-panel").forEach((p) => {
      p.classList.toggle("active", p.id === `tab-${tabId}`);
    });
    if (openDrawer) drawer.classList.remove("hidden");
  }

  function normalizePanelForDrawer(panelEl) {
    if (!panelEl) return;
    panelEl.style.position = "static";
    panelEl.style.top = "";
    panelEl.style.right = "";
    panelEl.style.left = "";
    panelEl.style.width = "100%";
    panelEl.style.maxHeight = "none";
    panelEl.style.overflow = "visible";
    panelEl.style.background = "transparent";
    panelEl.style.border = "none";
    panelEl.style.padding = "0";
    panelEl.style.display = "block";
    panelEl.style.zIndex = "auto";
  }

  function drawerSection(parent, title) {
    const section = document.createElement("div");
    section.style.marginBottom = "12px";
    const header = document.createElement("div");
    header.textContent = title;
    header.style.fontWeight = "bold";
    header.style.margin = "6px 0";
    header.style.opacity = "0.95";
    const body = document.createElement("div");
    body.style.display = "flex";
    body.style.flexDirection = "column";
    body.style.gap = "6px";
    section.appendChild(header);
    section.appendChild(body);
    parent.appendChild(section);
    return body;
  }

  function drawerControlNode(id) {
    const el = document.getElementById(id);
    if (!el) return null;
    const node = el.closest("label") || el;
    if (node.dataset.drawerMoved === "1") return null;
    node.dataset.drawerMoved = "1";
    node.style.display = "flex";
    node.style.alignItems = "center";
    node.style.gap = "8px";
    return node;
  }

  function moveControlTo(body, id) {
    const node = drawerControlNode(id);
    if (!node) return;
    body.appendChild(node);
  }

  function mountSceneAndSettingsControls() {
    const tabScene = document.getElementById("tab-scene");
    const tabSettings = document.getElementById("tab-settings");
    if (!tabScene || !tabSettings) return;

    tabScene.innerHTML = "";
    tabSettings.innerHTML = "";

    const scenePerms = drawerSection(tabScene, "Permissions");
    moveControlTo(scenePerms, "allowPlayersMove");
    moveControlTo(scenePerms, "allowAllMove");
    moveControlTo(scenePerms, "lockdown");

    const sceneBackground = drawerSection(tabScene, "Background");
    moveControlTo(sceneBackground, "bgUrl");
    moveControlTo(sceneBackground, "setBg");
    moveControlTo(sceneBackground, "terrainBg");
    moveControlTo(sceneBackground, "terrainStyle");
    moveControlTo(sceneBackground, "regenTerrain");
    moveControlTo(sceneBackground, "terrainBadge");

    const sceneLayers = drawerSection(tabScene, "Layers");
    moveControlTo(sceneLayers, "layerGrid");
    moveControlTo(sceneLayers, "layerDraw");
    moveControlTo(sceneLayers, "layerShapes");
    moveControlTo(sceneLayers, "layerTokens");

    const settingsTools = drawerSection(tabSettings, "Tool Defaults");
    moveControlTo(settingsTools, "color");
    moveControlTo(settingsTools, "size");

    const settingsGrid = drawerSection(tabSettings, "Grid & Measure");
    moveControlTo(settingsGrid, "feetPerSq");
    moveControlTo(settingsGrid, "snap");
    moveControlTo(settingsGrid, "grid");
    moveControlTo(settingsGrid, "showGrid");

    const hotkeys = drawerSection(tabSettings, "Hotkey Cheat Sheet");
    hotkeys.style.fontSize = "12px";
    hotkeys.style.opacity = "0.9";
    hotkeys.innerHTML = `
      <div><b>V</b> Move tool</div>
      <div><b>P</b> Pen tool</div>
      <div><b>S</b> Shape tool</div>
      <div><b>T</b> Text tool</div>
      <div><b>E</b> Eraser tool</div>
      <div><b>R</b> Ruler tool</div>
      <div><b>D</b> Toggle Downed badge (GM, selected token)</div>
      <div><b>Tab</b> Toggle drawer</div>
      <div><b>Delete/Backspace</b> Delete selected token (GM)</div>
      <div><b>Esc</b> Close menus / cancel drag spawn</div>
    `;
  }

  function mountDrawerPanels() {
    const tabTokens = document.getElementById("tab-tokens");
    const tabRooms = document.getElementById("tab-rooms");
    const tabPlayers = document.getElementById("tab-players");

    if (libraryPanel && tabTokens && libraryPanel.parentElement !== tabTokens) tabTokens.appendChild(libraryPanel);
    if (roomsPanel && tabRooms && roomsPanel.parentElement !== tabRooms) tabRooms.appendChild(roomsPanel);
    if (gmPanel && tabPlayers && gmPanel.parentElement !== tabPlayers) tabPlayers.appendChild(gmPanel);

    normalizePanelForDrawer(libraryPanel);
    normalizePanelForDrawer(roomsPanel);
    normalizePanelForDrawer(gmPanel);

    const roomsClose = document.getElementById("roomsPanelClose");
    const libraryClose = document.getElementById("libraryPanelClose");
    const gmClose = document.getElementById("gmPanelClose");
    if (roomsClose) roomsClose.style.display = "none";
    if (libraryClose) libraryClose.style.display = "none";
    if (gmClose) gmClose.style.display = "none";

    mountSceneAndSettingsControls();

    const gmBtn = document.getElementById("gmPanelBtn");
    const roomsBtn = document.getElementById("roomsPanelBtn");
    const libraryBtn = document.getElementById("libraryPanelBtn");
    if (gmBtn) gmBtn.style.display = "none";
    if (roomsBtn) roomsBtn.style.display = "none";
    if (libraryBtn) libraryBtn.style.display = "none";
  }

  function closeFloatingPanels(except = "") {
    if (except !== "gm" && except !== "rooms" && except !== "library") drawer.classList.add("hidden");
    if (except !== "token-menu") closeTokenMenu();
  }

  function closeTokenMenu() {
    tokenMenuEl.style.display = "none";
    tokenMenuTokenId = null;
  }

  function hideAllCtx() {
    if (ctxSubHideTimer) {
      clearTimeout(ctxSubHideTimer);
      ctxSubHideTimer = null;
    }
    for (const m of allCtxMenus) m.classList.add("hidden");
  }

  function hideToolPanels() {
    toolColorPanel.classList.add("hidden");
    toolSizePanel.classList.add("hidden");
  }

  function showFloatingToolPanel(panelEl, x, y) {
    hideToolPanels();
    panelEl.classList.remove("hidden");
    clampMenuToViewport(panelEl, x, y);
  }

  function isClickInsideToolPanel(target) {
    return !toolColorPanel.classList.contains("hidden") && toolColorPanel.contains(target)
      || !toolSizePanel.classList.contains("hidden") && toolSizePanel.contains(target);
  }

  function openToolColorPanel(title = "Color") {
    toolColorTitle.textContent = title;
    toolColorPicker.value = String(colorEl.value || "#ffffff");
    showFloatingToolPanel(toolColorPanel, lastCtxClientPos.x + 8, lastCtxClientPos.y + 8);
  }

  function openToolSizePanel(title = "Size") {
    const size = clamp(Number(sizeEl.value || "3"), 1, 30);
    toolSizeTitle.textContent = title;
    toolSizeSlider.value = String(Math.round(size));
    toolSizeValue.textContent = String(Math.round(size));
    showFloatingToolPanel(toolSizePanel, lastCtxClientPos.x + 8, lastCtxClientPos.y + 8);
  }

  function hideCtxSubs() {
    mapCtxBg.classList.add("hidden");
    mapCtxLayers.classList.add("hidden");
    mapCtxClear.classList.add("hidden");
  }

  function clearCtxSubHideTimer() {
    if (!ctxSubHideTimer) return;
    clearTimeout(ctxSubHideTimer);
    ctxSubHideTimer = null;
  }

  function scheduleCtxSubHide(delayMs = 120) {
    clearCtxSubHideTimer();
    ctxSubHideTimer = setTimeout(() => {
      hideCtxSubs();
      ctxSubHideTimer = null;
    }, delayMs);
  }

  function clampMenuToViewport(menuEl, x, y) {
    const wasHidden = menuEl.classList.contains("hidden");
    if (wasHidden) menuEl.classList.remove("hidden");
    const pad = 8;
    const w = menuEl.offsetWidth;
    const h = menuEl.offsetHeight;
    const maxX = window.innerWidth - w - pad;
    const maxY = window.innerHeight - h - pad;
    const cx = Math.max(pad, Math.min(x, maxX));
    const cy = Math.max(pad, Math.min(y, maxY));
    menuEl.style.left = `${cx}px`;
    menuEl.style.top = `${cy}px`;
    if (wasHidden) menuEl.classList.add("hidden");
  }

  function showMapMenu(x, y) {
    const gm = isGM();
    document.querySelectorAll("#mapCtx [data-gm='1'], #mapCtx-bg [data-gm='1'], #mapCtx-layers [data-gm='1'], #mapCtx-clear [data-gm='1']").forEach((el) => {
      el.style.display = gm ? "flex" : "none";
    });
    if (!gm) {
      mapCtxBg.classList.add("hidden");
      mapCtxLayers.classList.add("hidden");
      mapCtxClear.classList.add("hidden");
    }
    showContextMenu(mapCtx, x, y);
  }

  function setCtxChecked(action, checked) {
    const item = document.querySelector(`.ctx-item[data-action="${action}"]`);
    if (!item) return;
    if (!item.dataset.baseLabel) item.dataset.baseLabel = item.textContent.replace(/^‚úì\s*/, "");
    item.textContent = `${checked ? "‚úì " : ""}${item.dataset.baseLabel}`;
  }

  function refreshToolContextChecks() {
    const size = Number(sizeEl.value || "3");
    const color = String(colorEl.value || "").toLowerCase();
    const currentTool = tool();
    const feet = Number(feetPerSqEl.value || "5");
    const snapOn = !!snapEl.checked;

    setCtxChecked("pen_size_2", size === 2);
    setCtxChecked("pen_size_4", size === 4);
    setCtxChecked("pen_size_8", size === 8);
    setCtxChecked("pen_color_white", color === "#ffffff");
    setCtxChecked("pen_color_red", color === "#ff3b30");
    setCtxChecked("pen_color_green", color === "#34c759");
    setCtxChecked("pen_color_blue", color === "#0a84ff");

    setCtxChecked("shape_tool_rect", currentTool === "rect");
    setCtxChecked("shape_tool_circle", currentTool === "circle");
    setCtxChecked("shape_tool_line", currentTool === "line");
    setCtxChecked("shape_size_2", size === 2);
    setCtxChecked("shape_size_4", size === 4);
    setCtxChecked("shape_size_8", size === 8);
    setCtxChecked("shape_toggle_snap", snapOn);

    setCtxChecked("ruler_feet_5", feet === 5);
    setCtxChecked("ruler_feet_10", feet === 10);
    setCtxChecked("ruler_feet_15", feet === 15);
    setCtxChecked("ruler_toggle_snap", snapOn);
  }

  function showContextMenu(menuEl, x, y) {
    lastCtxClientPos = { x, y };
    refreshToolContextChecks();
    hideAllCtx();
    hideToolPanels();
    menuEl.classList.remove("hidden");
    clampMenuToViewport(menuEl, x, y);
  }

  function showSubMenu(subEl, parentRowEl) {
    clearCtxSubHideTimer();
    const rect = parentRowEl.getBoundingClientRect();
    const x = rect.right + 6;
    const y = rect.top;
    subEl.classList.remove("hidden");
    clampMenuToViewport(subEl, x, y);
  }

  function isClickInsideAnyCtxMenu(target) {
    return allCtxMenus.some((m) => !m.classList.contains("hidden") && m.contains(target));
  }

  function setLayerVisibility(next) {
    state.layer_visibility = { ...state.layer_visibility, ...next };
    layerGridEl.checked = !!state.layer_visibility.grid;
    layerDrawEl.checked = !!state.layer_visibility.drawings;
    layerShapesEl.checked = !!state.layer_visibility.shapes;
    layerTokensEl.checked = !!state.layer_visibility.tokens;
    send("ROOM_SETTINGS", { layer_visibility: state.layer_visibility });
    requestRender();
  }

  function spawnDefaultTokenAt(wx, wy) {
    if (!isGM()) return;
    const id = makeId();
    const name = "Token";
    const color = "#" + Math.floor(Math.random() * 16777215).toString(16).padStart(6, "0");
    const x = snap(wx);
    const y = snap(wy);
    const size_scale = ui.tokenSpawnScale;
    const token = { id, x, y, name, color, image_url: null, size_scale, owner_id: null, locked: false, badges: [] };
    if (online) {
      state.tokens.set(id, token);
      refreshGmUI();
      requestRender();
    }
    send("TOKEN_CREATE", token);
  }

  function clearDrawings() {
    if (!isGM()) return;
    const ids = Array.from(state.strokes.keys());
    if (!ids.length) return;
    send("STROKE_DELETE", { ids });
  }

  function clearShapes() {
    if (!isGM()) return;
    const ids = Array.from(state.shapes.keys());
    for (const id of ids) send("SHAPE_DELETE", { id });
  }

  function clearTokens() {
    if (!isGM()) return;
    const ids = Array.from(state.tokens.keys());
    for (const id of ids) send("TOKEN_DELETE", { id });
  }

  function handleCtxAction(action) {
    switch (action) {
      case "spawn_default": {
        const w = mapCtxWorld || screenToWorld(canvas.getBoundingClientRect().width / 2, canvas.getBoundingClientRect().height / 2);
        spawnDefaultTokenAt(w.x, w.y);
        break;
      }
      case "bg_solid":
        if (isGM()) send("ROOM_SETTINGS", { background_mode: "solid", background_url: null });
        break;
      case "bg_url":
        if (isGM()) {
          const url = prompt("Background image URL:", state.background_url || "");
          if (url !== null) send("ROOM_SETTINGS", { background_mode: (url.trim() ? "url" : "solid"), background_url: url.trim() || null });
        }
        break;
      case "bg_terrain":
        if (isGM()) send("ROOM_SETTINGS", { background_mode: "terrain", terrain_style: terrainStyleEl.value });
        break;
      case "bg_terrain_regen":
        if (isGM()) send("ROOM_SETTINGS", { background_mode: "terrain", terrain_seed: randomTerrainSeed(), terrain_style: terrainStyleEl.value });
        break;
      case "toggle_layer_grid":
        if (!isGM()) return;
        setLayerVisibility({ grid: !state.layer_visibility.grid });
        break;
      case "toggle_layer_drawings":
        if (!isGM()) return;
        setLayerVisibility({ drawings: !state.layer_visibility.drawings });
        break;
      case "toggle_layer_shapes":
        if (!isGM()) return;
        setLayerVisibility({ shapes: !state.layer_visibility.shapes });
        break;
      case "toggle_layer_tokens":
        if (!isGM()) return;
        setLayerVisibility({ tokens: !state.layer_visibility.tokens });
        break;
      case "clear_drawings":
        if (!isGM()) return;
        if (confirm("Clear drawings for this room?")) clearDrawings();
        break;
      case "clear_shapes":
        if (!isGM()) return;
        if (confirm("Clear shapes for this room?")) clearShapes();
        break;
      case "clear_tokens":
        if (!isGM()) return;
        if (confirm("Clear all tokens for this room?")) clearTokens();
        break;
      case "save_snapshot":
        if (isGM()) document.getElementById("saveSnapshotBtn").click();
        break;
      case "open_tokens":
        activateDrawerTab("tokens", true);
        break;
      case "open_rooms":
        activateDrawerTab("rooms", true);
        refreshRoomsPanel();
        refreshSnapshotsPanel();
        break;
      case "open_scene":
        activateDrawerTab("scene", true);
        break;
      case "pen_size_2":
        sizeEl.value = "2";
        break;
      case "pen_size_4":
        sizeEl.value = "4";
        break;
      case "pen_size_8":
        sizeEl.value = "8";
        break;
      case "pen_size_custom": {
        openToolSizePanel("Pen Size");
        break;
      }
      case "pen_color_white":
        colorEl.value = "#ffffff";
        break;
      case "pen_color_red":
        colorEl.value = "#ff3b30";
        break;
      case "pen_color_green":
        colorEl.value = "#34c759";
        break;
      case "pen_color_blue":
        colorEl.value = "#0a84ff";
        break;
      case "pen_color_custom": {
        openToolColorPanel("Pen Color");
        break;
      }
      case "shape_tool_rect":
        setTool("rect");
        break;
      case "shape_tool_circle":
        setTool("circle");
        break;
      case "shape_tool_line":
        setTool("line");
        break;
      case "shape_size_2":
        sizeEl.value = "2";
        break;
      case "shape_size_4":
        sizeEl.value = "4";
        break;
      case "shape_size_8":
        sizeEl.value = "8";
        break;
      case "shape_size_custom": {
        openToolSizePanel("Shape Stroke");
        break;
      }
      case "shape_color_custom": {
        openToolColorPanel("Shape Color");
        break;
      }
      case "shape_toggle_snap":
        snapEl.checked = !snapEl.checked;
        refreshUI();
        break;
      case "ruler_feet_5":
        feetPerSqEl.value = "5";
        refreshUI();
        break;
      case "ruler_feet_10":
        feetPerSqEl.value = "10";
        refreshUI();
        break;
      case "ruler_feet_15":
        feetPerSqEl.value = "15";
        refreshUI();
        break;
      case "ruler_toggle_snap":
        snapEl.checked = !snapEl.checked;
        refreshUI();
        break;
      case "ruler_clear":
        activeRuler = null;
        requestRender();
        break;
      default:
        break;
    }
  }

  function normalizedBadgeList(input) {
    if (!Array.isArray(input)) return [];
    const out = [];
    for (const raw of input) {
      const id = String(raw || "").trim();
      if (!TOKEN_BADGE_IDS.has(id)) continue;
      if (!out.includes(id)) out.push(id);
    }
    return out;
  }

  function tokenBadgesSet(token) {
    return new Set(normalizedBadgeList(token?.badges));
  }

  function refreshTokenMenuBadgeButtons() {
    if (!tokenMenuTokenId) return;
    const t = state.tokens.get(tokenMenuTokenId);
    const current = tokenBadgesSet(t);
    for (const badge of TOKEN_BADGES) {
      const btn = document.getElementById(badge.menuId);
      if (!btn) continue;
      btn.textContent = `${current.has(badge.id) ? "‚úì " : ""}${badge.label}`;
    }
    const clearBtn = document.getElementById("tokenMenuBadgeClear");
    if (clearBtn) clearBtn.style.opacity = current.size ? "1" : "0.6";
  }

  function sendTokenBadgeToggle(tokenId, badgeId, enabled = null) {
    send("TOKEN_BADGE_TOGGLE", { id: tokenId, badge: badgeId, enabled });
  }

  function setTokenBadgeLocal(tokenId, badgeId, enabled = null) {
    const t = state.tokens.get(tokenId);
    if (!t || !TOKEN_BADGE_IDS.has(badgeId)) return;
    const next = tokenBadgesSet(t);
    if (enabled === true) next.add(badgeId);
    else if (enabled === false) next.delete(badgeId);
    else if (next.has(badgeId)) next.delete(badgeId);
    else next.add(badgeId);
    t.badges = Array.from(next).sort();
    state.tokens.set(tokenId, t);
  }

  function openTokenMenu(tokenId, clientX, clientY) {
    tokenMenuTokenId = tokenId;
    const t = state.tokens.get(tokenId);
    const lockBtn = document.getElementById("tokenMenuLock");
    if (lockBtn) lockBtn.textContent = t?.locked ? "Unlock" : "Lock";
    refreshTokenMenuBadgeButtons();
    const wrapRect = document.getElementById("wrap").getBoundingClientRect();
    tokenMenuEl.style.display = "block";
    tokenMenuEl.style.visibility = "hidden";
    const menuRect = tokenMenuEl.getBoundingClientRect();
    const clientXClamped = Math.min(clientX, window.innerWidth - menuRect.width - 8);
    const clientYClamped = Math.min(clientY, window.innerHeight - menuRect.height - 8);
    const x = clamp(clientXClamped - wrapRect.left, 8, Math.max(8, wrapRect.width - menuRect.width - 8));
    const y = clamp(clientYClamped - wrapRect.top, 8, Math.max(8, wrapRect.height - menuRect.height - 8));
    tokenMenuEl.style.left = `${x}px`;
    tokenMenuEl.style.top = `${y}px`;
    tokenMenuEl.style.visibility = "visible";
    tokenMenuEl.style.display = "block";
  }

  function openSessionModal() {
    sessionRoomEl.value = roomEl.value.trim() || "demo";
    sessionClientEl.value = cidEl.value.trim() || "player";
    refreshSessionModalAuth();
    sessionModal.classList.remove("hidden");
    sessionModalBackdrop.classList.remove("hidden");
  }

  function closeSessionModal() {
    sessionModal.classList.add("hidden");
    sessionModalBackdrop.classList.add("hidden");
  }

  function updateSessionPill() {
    const connected = online && !!(ws && ws.readyState === 1);
    const roomText = (state.room_id || roomEl.value.trim() || "demo");
    const cidText = myId() || "player";
    const role = isGM() ? "GM" : "Player";
    if (connected) {
      sessionPill.textContent = `‚óè Connected - ${roomText} ‚Ä¢ ${cidText} (${role})`;
      sessionPill.classList.add("ok");
      sessionPill.classList.remove("bad");
      sessionDisconnectBtn.classList.remove("hidden");
    } else {
      sessionPill.textContent = "‚óã Disconnected - Single Session Mode";
      sessionPill.classList.add("bad");
      sessionPill.classList.remove("ok");
      sessionDisconnectBtn.classList.add("hidden");
    }
  }

  function refreshSessionModalAuth() {
    const connected = online && !!(ws && ws.readyState === 1);
    if (connected) {
      sessionModalTitleEl.textContent = `Connected - ${state.room_id || roomEl.value.trim() || "room"}`;
      sessionStatusTextEl.textContent = isGM() ? "You are GM in this room." : "You are connected as Player.";
    } else {
      sessionModalTitleEl.textContent = "Disconnected - Single Session Mode";
      sessionStatusTextEl.textContent = "Everything works locally. Log in to host or join a shared room.";
    }
    if (me && me.username) {
      sessionAuthBoxEl.classList.add("hidden");
      sessionAccountBoxEl.classList.remove("hidden");
      sessionWhoamiEl.textContent = `Signed in as ${me.username}`;
    } else {
      sessionAuthBoxEl.classList.remove("hidden");
      sessionAccountBoxEl.classList.add("hidden");
      sessionWhoamiEl.textContent = "";
    }
  }

  function flashToolActivate(el) {
    if (!el) return;
    el.classList.remove("tool-activate");
    // Reflow so repeated toggles replay animation.
    void el.offsetWidth;
    el.classList.add("tool-activate");
  }

  function hideTooltip() {
    if (tooltipTimer) {
      clearTimeout(tooltipTimer);
      tooltipTimer = null;
    }
    uiTooltip.classList.add("hidden");
  }

  function showTooltipFor(el) {
    if (!el) return;
    const text = el.dataset.tip;
    if (!text) return;
    hideTooltip();
    tooltipTimer = setTimeout(() => {
      uiTooltip.textContent = text;
      uiTooltip.classList.remove("hidden");
      const rect = el.getBoundingClientRect();
      const pad = 8;
      const tw = uiTooltip.offsetWidth;
      const th = uiTooltip.offsetHeight;
      const x = Math.max(pad, Math.min(rect.left + rect.width / 2 - tw / 2, window.innerWidth - tw - pad));
      const y = Math.max(pad, rect.bottom + 8);
      uiTooltip.style.left = `${x}px`;
      uiTooltip.style.top = `${y}px`;
    }, 300);
  }

  function updateCanvasCursor() {
    if (dragSpawn) {
      canvas.style.cursor = "copy";
      return;
    }
    const t = tool();
    if (isPanning || (t === "move" && draggingTokenId)) {
      canvas.style.cursor = "grabbing";
      return;
    }
    if (t === "move") {
      canvas.style.cursor = "grab";
      return;
    }
    if (t === "pen" || t === "rect" || t === "circle" || t === "line" || t === "text" || t === "ruler") {
      canvas.style.cursor = "crosshair";
      return;
    }
    if (t === "eraser") {
      canvas.style.cursor = "not-allowed";
      return;
    }
    canvas.style.cursor = "default";
  }

  function applyTokenSizePreset(scale) {
    ui.tokenSpawnScale = scale;
    for (const [k, btn] of Object.entries(sizePresetButtons)) {
      if (!btn) continue;
      btn.classList.toggle("active", Math.abs(parseFloat(k) - scale) < 0.01);
    }
    if (selectedTokenId && isGM()) {
      const tok = state.tokens.get(selectedTokenId);
      if (tok) {
        if (online) {
          tok.size_scale = scale;
          state.tokens.set(selectedTokenId, tok);
        }
        send("TOKEN_SET_SIZE", { id: selectedTokenId, size_scale: scale });
        if (online) requestRender();
      }
    }
    scheduleOfflineSave();
  }

  function markInboundChange() {
    lastInboundChangeTs = Date.now();
  }

  function showResyncBadge() {
    if (!sessionResyncBadge) return;
    sessionResyncBadge.classList.remove("hidden");
    if (resyncBadgeTimer) clearTimeout(resyncBadgeTimer);
    resyncBadgeTimer = setTimeout(() => {
      hideResyncBadge();
    }, 2000);
  }

  function hideResyncBadge() {
    if (!sessionResyncBadge) return;
    sessionResyncBadge.classList.add("hidden");
    if (resyncBadgeTimer) {
      clearTimeout(resyncBadgeTimer);
      resyncBadgeTimer = null;
    }
  }

  function ensureStaleWatchdog() {
    if (staleSyncTimer) return;
    staleSyncTimer = setInterval(() => {
      if (!online || !ws || ws.readyState !== WebSocket.OPEN) return;
      if (!seenInboundMutationSinceConnect) return;
      // If no state-changing messages arrive for a while, request an authoritative sync.
      const age = Date.now() - lastInboundChangeTs;
      const sinceLastReq = Date.now() - lastResyncRequestTs;
      if (age > 10000 && sinceLastReq > 10000) {
        lastResyncRequestTs = Date.now();
        try {
          showResyncBadge();
          ws.send(JSON.stringify({ type: "REQ_STATE_SYNC", payload: {} }));
          log("No recent updates detected; requested state sync.");
        } catch (e) {
          hideResyncBadge();
          console.error("REQ_STATE_SYNC send failed", e);
        }
      }
    }, 5000);
  }

  function renderPackGrid() {
    const q = packState.search.toLowerCase().trim();
    const rows = packState.tokens.filter((t) => {
      if (!q) return true;
      const hay = `${t.name} ${t.tags.join(" ")}`.toLowerCase();
      return hay.includes(q);
    });

    if (!rows.length) {
      packGridEl.innerHTML = `<div style="opacity:.75; grid-column:1/-1;">(no tokens match)</div>`;
      return;
    }

    packGridEl.innerHTML = rows.map((t, idx) => `
      <button
        data-pack-idx="${idx}"
        style="padding:6px; border:1px solid rgba(255,255,255,0.14); background:rgba(255,255,255,0.03); color:#eee; text-align:center;"
        title="${escapeHtml(t.name)}">
        <div style="width:100%; aspect-ratio:1/1; border-radius:8px; overflow:hidden; background:#1a1a1a; display:flex; align-items:center; justify-content:center;">
          <img src="${escapeHtml(t.image_url)}" alt="${escapeHtml(t.name)}" style="width:100%; height:100%; object-fit:cover;">
        </div>
        <div style="margin-top:6px; font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${escapeHtml(t.name)}</div>
      </button>
    `).join("");

    packGridEl.querySelectorAll("button[data-pack-idx]").forEach((btn) => {
      const idx = Number(btn.getAttribute("data-pack-idx"));
      const t = rows[idx];
      if (!t) return;

      btn.onclick = () => spawnPackToken(t);
      btn.onpointerdown = (e) => {
        if (e.button !== 0) return;
        dragSpawn = { ...t, size_scale: ui.tokenSpawnScale };
        dragSpawnWorld = null;
        dragSpawnOverCanvas = false;
        e.preventDefault();
      };
    });
  }

  async function loadPack(packId) {
    if (!packId) {
      packState.tokens = [];
      renderPackGrid();
      return;
    }
    try {
      const manifest = await apiGet(`/api/packs/${encodeURIComponent(packId)}`);
      const tokens = [];
      for (const token of (manifest.tokens || [])) {
        const normalized = sanitizePackToken(token, packId);
        if (normalized) tokens.push(normalized);
      }
      packState.tokens = tokens;
      renderPackGrid();
    } catch (e) {
      packState.tokens = [];
      packGridEl.innerHTML = `<div style="color:#ffb3b3; grid-column:1/-1;">Pack load failed</div>`;
      log(`PACK LOAD ERROR: ${e.message || e}`);
    }
  }

  async function refreshPacks() {
    try {
      const data = await apiGet("/api/packs");
      const packs = Array.isArray(data.packs) ? data.packs : [];
      packState.packs = packs;
      const existing = new Set(packs.map((p) => p.pack_id));
      if (!existing.has(packState.selectedPackId)) {
        packState.selectedPackId = packs[0]?.pack_id || "";
      }
      packSelectEl.innerHTML = packs.map((p) => (
        `<option value="${p.pack_id}">${p.name} (${p.token_count})</option>`
      )).join("") || `<option value="">(no packs)</option>`;
      packSelectEl.value = packState.selectedPackId || "";
      await loadPack(packState.selectedPackId);
    } catch (e) {
      packState.packs = [];
      packState.tokens = [];
      packSelectEl.innerHTML = `<option value="">(packs unavailable)</option>`;
      packGridEl.innerHTML = `<div style="color:#ffb3b3; grid-column:1/-1;">Packs load failed</div>`;
      log(`PACKS ERROR: ${e.message || e}`);
    }
  }

  function spawnPackToken(packToken, x = null, y = null) {
    const id = makeId();
    let wx = x;
    let wy = y;
    if (wx === null || wy === null) {
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;
      const centerWorld = screenToWorld(w / 2, h / 2);
      wx = snap(centerWorld.x + (Math.random() * 80 - 40));
      wy = snap(centerWorld.y + (Math.random() * 80 - 40));
    }

    const token = {
      id,
      x: wx,
      y: wy,
      name: packToken.name || "Token",
      color: packToken.color || "#ffffff",
      image_url: packToken.image_url || null,
      size_scale: clamp(Number(packToken.size_scale ?? ui.tokenSpawnScale), 0.25, 4),
      owner_id: null,
      locked: false,
      badges: [],
    };
    if (online) {
      state.tokens.set(id, token);
      refreshGmUI();
      requestRender();
    }
    send("TOKEN_CREATE", token);
  }

  let ws = null;
  let wsConnectSeq = 0;
  let appInitialized = false;
  let heartbeatTimer = null;
  let staleSyncTimer = null;
  let lastInboundChangeTs = Date.now();
  let lastResyncRequestTs = 0;
  let resyncBadgeTimer = null;
  let seenInboundMutationSinceConnect = false;
  const players = new Set();
  const STATE_CHANGE_EVENTS = new Set([
    "STATE_SYNC",
    "ROOM_SETTINGS",
    "TOKEN_CREATE",
    "TOKEN_MOVE",
    "TOKEN_DELETE",
    "TOKEN_ASSIGN",
    "TOKEN_RENAME",
    "TOKEN_SET_SIZE",
    "TOKEN_SET_LOCK",
    "TOKEN_BADGE_TOGGLE",
    "STROKE_ADD",
    "STROKE_DELETE",
    "STROKE_SET_LOCK",
    "ERASE_AT",
    "SHAPE_ADD",
    "SHAPE_UPDATE",
    "SHAPE_DELETE",
    "SHAPE_SET_LOCK",
  ]);
  const WATCHDOG_MUTATION_EVENTS = new Set([
    "ROOM_SETTINGS",
    "TOKEN_CREATE",
    "TOKEN_MOVE",
    "TOKEN_DELETE",
    "TOKEN_ASSIGN",
    "TOKEN_RENAME",
    "TOKEN_SET_SIZE",
    "TOKEN_SET_LOCK",
    "TOKEN_BADGE_TOGGLE",
    "STROKE_ADD",
    "STROKE_DELETE",
    "STROKE_SET_LOCK",
    "ERASE_AT",
    "SHAPE_ADD",
    "SHAPE_UPDATE",
    "SHAPE_DELETE",
    "SHAPE_SET_LOCK",
  ]);

  const state = {
    room_id: null,
    gm_id: null,
    allow_players_move: false,
    allow_all_move: false,
    lockdown: false,
    background_mode: "solid",
    background_url: null,
    terrain_seed: 1,
    terrain_style: "grassland",
    layer_visibility: { grid: true, drawings: true, shapes: true, tokens: true },
    draw_order: { strokes: [], shapes: [] },
    version: 0,
    tokens: new Map(),
    strokes: new Map(),
    shapes: new Map(),
  };
  const packState = {
    packs: [],
    selectedPackId: "",
    tokens: [],
    search: "",
  };

  function myId() { return cidEl.value.trim(); }
  function isGM() { return state.gm_id && myId() === state.gm_id; }
  function ensureOfflineGm() {
    if (online) return;
    const cid = myId() || "player";
    if (!state.gm_id) state.gm_id = cid;
    if (!state.room_id) state.room_id = "offline";
    players.clear();
    players.add(cid);
    refreshGmUI();
  }

  const cam = { x: 80, y: 60, z: 1 };
  const ui = { gridSize: 50, snap: true, showGrid: true, feetPerSq: 5, tokenSpawnScale: 1.0 };

  let draggingTokenId = null;
  let draggingShapeId = null;
  let selectedTokenId = null;
  let selectedShapeId = null;
  let hoveredTokenId = null;
  let dragOffset = { x: 0, y: 0 };
  let shapeDragOrigin = null;
  let isPanning = false;
  let isShiftDown = false;
  let panStart = { sx: 0, sy: 0, camX: 0, camY: 0 };
  let pointerCaptured = false;

  let activeStroke = null;
  let activeShapePreview = null;
  let activeRuler = null;
  let erasingActive = false;
  let lastEraseWorld = null;

  let lastMoveSentAt = 0;
  const MOVE_SEND_INTERVAL_MS = 33;
  let lastEraseSentAt = 0;
  const ERASE_SEND_INTERVAL_MS = 40;
  let dragSpawn = null;
  let dragSpawnWorld = null;
  let dragSpawnOverCanvas = false;
  let tokenMenuTokenId = null;
  let mapCtxWorld = null;
  let ctxSubHideTimer = null;
  let lastShapeTool = "rect";
  let lastCtxClientPos = { x: 24, y: 24 };
  let tooltipTimer = null;

  let bgImage = null;
  let bgImageUrl = null;
  let bgImageStatus = "idle";
  const bgCache = new Map();
  const tokenImageCache = new Map();
  const TERRAIN_MACRO_TILE = 1024;
  const TERRAIN_MICRO_TILE = 512;
  const TERRAIN_BREAKUP_TILE = 1536;
  const TERRAIN_STYLES = new Set(["grassland", "dirt", "snow", "desert"]);
  const BIOME_PALETTES = {
    grassland: {
      base: "#2f5f2a",
      speckA: "#3c7034",
      speckB: "#275227",
      strokeA: "#3f7a35",
      strokeB: "#204820",
      stain: "#bda46a",
      pebbleA: "#7c7c7c",
      pebbleB: "#6b635a",
      shadowShade: [14, 22, 14],
    },
    dirt: {
      base: "#5a4934",
      speckA: "#6a573f",
      speckB: "#4a3a2a",
      strokeA: "#7b6546",
      strokeB: "#3c2f22",
      stain: "#9f8458",
      pebbleA: "#8b7b67",
      pebbleB: "#665845",
      shadowShade: [18, 16, 12],
    },
    snow: {
      base: "#d7dde0",
      speckA: "#e6eef2",
      speckB: "#c7d1d7",
      strokeA: "#c8d8e2",
      strokeB: "#b3c0c8",
      stain: "#b8c2ca",
      pebbleA: "#9ca8b3",
      pebbleB: "#7f8a93",
      shadowShade: [28, 30, 33],
    },
    desert: {
      base: "#c9ad71",
      speckA: "#d7bb7c",
      speckB: "#b99560",
      strokeA: "#cfb074",
      strokeB: "#a6844f",
      stain: "#b58f53",
      pebbleA: "#8f7550",
      pebbleB: "#6f5a3d",
      shadowShade: [24, 20, 12],
    },
  };
  const terrain = {
    seed: null,
    gridSize: null,
    style: null,
    patternA: null,
    patternB: null,
    patternC: null,
    tileA: null,
    tileB: null,
    tileC: null,
  };

  function normalizeBackgroundMode(mode, bgUrl) {
    if (mode === "terrain" || mode === "url" || mode === "solid") return mode;
    return bgUrl ? "url" : "solid";
  }

  function normalizeTerrainSeed(seed, fallback = 1) {
    const parsed = Number(seed);
    if (Number.isFinite(parsed) && parsed > 0) return Math.floor(parsed);
    return fallback;
  }

  function normalizeTerrainStyle(style) {
    return TERRAIN_STYLES.has(style) ? style : "grassland";
  }

  function randomTerrainSeed() {
    if (window.crypto && crypto.getRandomValues) {
      const a = new Uint32Array(1);
      crypto.getRandomValues(a);
      return Math.max(1, (a[0] & 0x7fffffff));
    }
    return Math.floor(Math.random() * 2_147_483_647) + 1;
  }

  function terrainScaleFromGrid(gridSize) {
    return clamp((gridSize || 50) / 50, 0.55, 2.4);
  }

  function mulberry32(seed) {
    let s = seed >>> 0;
    return function () {
      let t = s += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function shadeColor(baseRgb, variance, rnd) {
    const r = clamp(Math.round(baseRgb[0] + (rnd() - 0.5) * variance), 0, 255);
    const g = clamp(Math.round(baseRgb[1] + (rnd() - 0.5) * variance), 0, 255);
    const b = clamp(Math.round(baseRgb[2] + (rnd() - 0.5) * variance), 0, 255);
    return `rgb(${r},${g},${b})`;
  }

  function colorWithAlpha(color, alpha) {
    const a = clamp(alpha, 0, 1);
    if (typeof color !== "string") return `rgba(0,0,0,${a})`;
    const hex = color.trim();
    if (hex.startsWith("#")) {
      const raw = hex.slice(1);
      const full = raw.length === 3
        ? raw.split("").map((ch) => ch + ch).join("")
        : raw;
      if (full.length === 6) {
        const r = parseInt(full.slice(0, 2), 16);
        const g = parseInt(full.slice(2, 4), 16);
        const b = parseInt(full.slice(4, 6), 16);
        return `rgba(${r},${g},${b},${a})`;
      }
    }
    return color;
  }

  function drawCloudShadows(c, rnd, tileSize, intensity = 0.045) {
    const clouds = 2 + Math.floor(rnd() * 2);
    for (let i = 0; i < clouds; i++) {
      const cx = rnd() * tileSize;
      const cy = rnd() * tileSize;
      const r = tileSize * (0.33 + rnd() * 0.27);
      const g = c.createRadialGradient(cx, cy, r * 0.2, cx, cy, r);
      g.addColorStop(0, `rgba(0,0,0,${intensity})`);
      g.addColorStop(1, "rgba(0,0,0,0)");
      c.fillStyle = g;
      c.beginPath();
      c.arc(cx, cy, r, 0, Math.PI * 2);
      c.fill();
    }
  }

  function buildTerrainPattern(ctxMain, seed, tileSize = 512, opts = {}) {
    const mode = opts.mode || "macro";
    const scale = clamp(opts.scale || 1, 0.55, 2.4);
    const style = normalizeTerrainStyle(opts.style);
    const palette = BIOME_PALETTES[style];
    const off = document.createElement("canvas");
    off.width = tileSize;
    off.height = tileSize;
    const c = off.getContext("2d");
    const rnd = mulberry32(seed);
    const clampByte = (v) => Math.max(0, Math.min(255, v));

    c.fillStyle = palette.base;
    c.fillRect(0, 0, tileSize, tileSize);

    if (mode === "macro" || mode === "macro_soft") {
      c.globalAlpha = mode === "macro_soft" ? 0.04 : 0.07;
      const macroSpeckleCount = mode === "macro_soft"
        ? Math.max(1200, Math.floor(3200 / Math.sqrt(scale)))
        : Math.max(1600, Math.floor(5200 / Math.sqrt(scale)));
      for (let i = 0; i < macroSpeckleCount; i++) {
        const x = rnd() * tileSize;
        const y = rnd() * tileSize;
        const szBase = mode === "macro_soft" ? 14 : 8;
        const szRange = mode === "macro_soft" ? 30 : 24;
        const sz = (szBase + rnd() * szRange) * scale;
        c.fillStyle = rnd() < 0.5 ? palette.speckA : palette.speckB;
        c.fillRect(x, y, sz, sz);
      }

      const patchCount = mode === "macro_soft"
        ? Math.max(2, Math.round(3 / Math.sqrt(scale)))
        : Math.max(2, Math.round(3 / Math.sqrt(scale)));
      for (let b = 0; b < patchCount; b++) {
        const cx = rnd() * tileSize;
        const cy = rnd() * tileSize;
        const scaleMin = mode === "macro_soft" ? 0.22 : 0.12;
        const scaleRange = mode === "macro_soft" ? 0.20 : 0.16;
        const r = tileSize * (scaleMin + rnd() * scaleRange) * scale;
        const g = c.createRadialGradient(cx, cy, r * 0.15, cx, cy, r);
        const stainAlpha = mode === "macro_soft" ? 0.05 : 0.08;
        g.addColorStop(0, colorWithAlpha(palette.stain, stainAlpha));
        g.addColorStop(1, colorWithAlpha(palette.stain, 0));
        c.fillStyle = g;
        c.beginPath();
        c.arc(cx, cy, r, 0, Math.PI * 2);
        c.fill();

        c.globalAlpha = mode === "macro_soft" ? 0.03 : 0.045;
        const edgeCount = Math.max(14, Math.round(36 / Math.sqrt(scale)));
        for (let k = 0; k < edgeCount; k++) {
          c.save();
          c.translate(cx + (rnd() - 0.5) * r * 0.9, cy + (rnd() - 0.5) * r * 0.9);
          c.rotate(rnd() * Math.PI * 2);
          c.scale(1 + rnd() * 1.7, 0.6 + rnd() * 0.9);
          c.fillStyle = palette.stain;
          c.beginPath();
          c.arc(0, 0, r * (0.10 + rnd() * 0.20), 0, Math.PI * 2);
          c.fill();
          c.restore();
        }
      }
      c.globalAlpha = 1;

      if (mode === "macro") {
        c.globalAlpha = 0.08;
        const macroStrokeCount = Math.max(280, Math.round(900 / scale));
        for (let i = 0; i < macroStrokeCount; i++) {
          const x = rnd() * tileSize;
          const y = rnd() * tileSize;
          const len = (5 + rnd() * 10) * scale;
          const ang = rnd() * Math.PI * 2;
          c.strokeStyle = rnd() < 0.45 ? palette.strokeA : palette.strokeB;
          c.lineWidth = 1;
          c.beginPath();
          c.moveTo(x, y);
          c.lineTo(x + Math.cos(ang) * len, y + Math.sin(ang) * len);
          c.stroke();
        }
        c.globalAlpha = 1;
      }

      drawCloudShadows(c, rnd, tileSize, mode === "macro_soft" ? 0.035 : 0.05);
    } else {
      const img = c.getImageData(0, 0, tileSize, tileSize);
      const d = img.data;
      for (let i = 0; i < d.length; i += 4) {
        const n = (rnd() - 0.5) * 18;
        d[i + 0] = clampByte(d[i + 0] + n);
        d[i + 1] = clampByte(d[i + 1] + n);
        d[i + 2] = clampByte(d[i + 2] + n);
      }
      c.putImageData(img, 0, 0);

      c.globalAlpha = 0.14;
      const microStrokeCount = Math.max(1200, Math.round(2600 / Math.sqrt(scale)));
      for (let i = 0; i < microStrokeCount; i++) {
        const x = rnd() * tileSize;
        const y = rnd() * tileSize;
        const len = (1.3 + rnd() * 3.4) * Math.sqrt(scale);
        const ang = rnd() * Math.PI * 2;
        c.strokeStyle = rnd() < 0.55 ? palette.strokeA : palette.strokeB;
        c.lineWidth = 1;
        c.beginPath();
        c.moveTo(x, y);
        c.lineTo(x + Math.cos(ang) * len, y + Math.sin(ang) * len);
        c.stroke();
      }
      c.globalAlpha = 1;

      c.globalAlpha = 0.08;
      const microSpeckleCount = Math.max(1800, Math.round(4200 / Math.sqrt(scale)));
      for (let i = 0; i < microSpeckleCount; i++) {
        const x = rnd() * tileSize;
        const y = rnd() * tileSize;
        c.fillStyle = shadeColor(palette.shadowShade, 42, rnd);
        c.fillRect(x, y, 1, 1);
      }
      c.globalAlpha = 1;

      const clusterCount = Math.max(10, Math.round(24 / Math.sqrt(scale)));
      for (let cl = 0; cl < clusterCount; cl++) {
        const cx = rnd() * tileSize;
        const cy = rnd() * tileSize;
        const members = 2 + Math.floor(rnd() * 6);
        for (let i = 0; i < members; i++) {
          const x = cx + (rnd() - 0.5) * 24;
          const y = cy + (rnd() - 0.5) * 24;
          const r = (0.9 + rnd() * 2.6) * Math.sqrt(scale);

          c.globalAlpha = 0.18;
          c.fillStyle = "#000";
          c.beginPath();
          c.arc(x + 0.8, y + 0.8, r, 0, Math.PI * 2);
          c.fill();

          c.globalAlpha = 0.55;
          c.fillStyle = rnd() < 0.5 ? palette.pebbleA : palette.pebbleB;
          c.beginPath();
          c.arc(x, y, r, 0, Math.PI * 2);
          c.fill();
        }
      }
      c.globalAlpha = 1;
    }

    return { tileCanvas: off, pattern: ctxMain.createPattern(off, "repeat") };
  }

  function ensureTerrain(seed, style = state.terrain_style) {
    const nextSeed = normalizeTerrainSeed(seed, 1);
    const nextStyle = normalizeTerrainStyle(style);
    const nextGridSize = clamp(Math.round(ui.gridSize || 50), 10, 300);
    const terrainScale = terrainScaleFromGrid(nextGridSize);
    if (terrain.seed === nextSeed && terrain.style === nextStyle && terrain.gridSize === nextGridSize && terrain.patternA && terrain.patternB && terrain.patternC) return;
    const builtA = buildTerrainPattern(ctx, nextSeed, TERRAIN_MACRO_TILE, { mode: "macro", scale: terrainScale, style: nextStyle });
    const builtB = buildTerrainPattern(ctx, (nextSeed ^ 0x9e3779b9) >>> 0, TERRAIN_MICRO_TILE, { mode: "micro", scale: terrainScale, style: nextStyle });
    const builtC = buildTerrainPattern(ctx, (nextSeed ^ 0x85ebca6b) >>> 0, TERRAIN_BREAKUP_TILE, { mode: "macro_soft", scale: terrainScale * 1.15, style: nextStyle });
    terrain.seed = nextSeed;
    terrain.gridSize = nextGridSize;
    terrain.style = nextStyle;
    terrain.patternA = builtA.pattern;
    terrain.patternB = builtB.pattern;
    terrain.patternC = builtC.pattern;
    terrain.tileA = builtA.tileCanvas;
    terrain.tileB = builtB.tileCanvas;
    terrain.tileC = builtC.tileCanvas;
  }

  function drawTerrainBackground() {
    if (!terrain.patternA || !terrain.patternB || !terrain.patternC) return;
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const topLeft = screenToWorld(0, 0);
    const botRight = screenToWorld(w, h);

    ctx.save();
    ctx.translate(cam.x, cam.y);
    ctx.scale(cam.z, cam.z);
    ctx.globalAlpha = 1.0;
    ctx.fillStyle = terrain.patternA;
    ctx.fillRect(topLeft.x, topLeft.y, botRight.x - topLeft.x, botRight.y - topLeft.y);
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = terrain.patternB;
    ctx.fillRect(topLeft.x, topLeft.y, botRight.x - topLeft.x, botRight.y - topLeft.y);
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = terrain.patternC;
    ctx.fillRect(topLeft.x, topLeft.y, botRight.x - topLeft.x, botRight.y - topLeft.y);
    ctx.globalAlpha = 1.0;
    ctx.restore();

    // Slight edge darkening improves token/readability over textured terrain.
    ctx.save();
    const g = ctx.createRadialGradient(w / 2, h / 2, 100, w / 2, h / 2, Math.max(w, h) * 0.75);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,0.22)");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, w, h);
    ctx.restore();
  }

  function setBackgroundUrl(url) {
    const next = url || null;
    if (next === bgImageUrl) return;
    bgImageUrl = next;
    if (!next) {
      bgImage = null;
      bgImageStatus = "idle";
      requestRender();
      return;
    }
    if (bgCache.has(next)) {
      bgImage = bgCache.get(next);
      bgImageStatus = "ready";
      requestRender();
      return;
    }
    bgImageStatus = "loading";
    bgImage = null;
    const img = new Image();
    img.onload = () => {
      if (bgImageUrl === next) {
        bgImage = img;
        bgCache.set(next, img);
        bgImageStatus = "ready";
        requestRender();
      }
    };
    img.onerror = () => {
      bgImageStatus = "error";
      log("BG failed to load");
      requestRender();
    };
    img.src = next;
  }

  function applyBackgroundState(mode, url, seed, style) {
    state.background_url = url || null;
    state.background_mode = normalizeBackgroundMode(mode, state.background_url);
    state.terrain_seed = normalizeTerrainSeed(seed, state.terrain_seed || 1);
    state.terrain_style = normalizeTerrainStyle(style || state.terrain_style);
    if (state.background_mode === "url") setBackgroundUrl(state.background_url);
    else setBackgroundUrl(null);
    if (state.background_mode === "terrain") ensureTerrain(state.terrain_seed, state.terrain_style);
  }

  function refreshTerrainBadge() {
    if (!isGM() || state.background_mode !== "terrain") {
      terrainBadgeEl.style.display = "none";
      terrainBadgeEl.textContent = "";
      return;
    }
    terrainBadgeEl.textContent = `Terrain: ${state.terrain_style} (seed ${state.terrain_seed})`;
    terrainBadgeEl.style.display = "inline-block";
  }

  function refreshGmUI() {
    const gm = isGM();

    allowPlayersMoveEl.disabled = !gm;
    allowAllMoveEl.disabled = !gm;
    lockdownEl.disabled = !gm;
    bgUrlEl.disabled = !gm;
    terrainBgEl.disabled = !gm;
    terrainStyleEl.disabled = !gm;
    document.getElementById("setBg").disabled = !gm;
    regenTerrainEl.disabled = !gm;
    document.getElementById("undo").disabled = !gm;
    document.getElementById("redo").disabled = !gm;

    [layerGridEl, layerDrawEl, layerShapesEl, layerTokensEl].forEach((el) => { el.disabled = !gm; });

    allowPlayersMoveEl.checked = !!state.allow_players_move;
    allowAllMoveEl.checked = !!state.allow_all_move;
    lockdownEl.checked = !!state.lockdown;
    layerGridEl.checked = !!state.layer_visibility.grid;
    layerDrawEl.checked = !!state.layer_visibility.drawings;
    layerShapesEl.checked = !!state.layer_visibility.shapes;
    layerTokensEl.checked = !!state.layer_visibility.tokens;
    bgUrlEl.value = state.background_url || "";
    terrainBgEl.checked = state.background_mode === "terrain";
    terrainStyleEl.value = state.terrain_style || "grassland";
    refreshTerrainBadge();

    const arr = Array.from(players).sort();
    playerListEl.innerHTML = arr.map((id) => {
      const tag = id === state.gm_id ? " (GM)" : "";
      return `<div>${id}${tag}</div>`;
    }).join("") || `<div style="opacity:.7">(none yet)</div>`;

    if (!gm) {
      tokenListEl.innerHTML = `<div style="opacity:.7">Only GM can edit token ownership/locks.</div>`;
      strokeListEl.innerHTML = `<div style="opacity:.7">Only GM can lock strokes.</div>`;
      shapeListEl.innerHTML = `<div style="opacity:.7">Only GM can lock shapes.</div>`;
      return;
    }

    const ownerOptions = ["", ...arr];
    const tokenRows = [];
    for (const [id, t] of state.tokens) {
      const opts = ownerOptions.map((o) => {
        const label = o === "" ? "(unassigned)" : o;
        const sel = ((t.owner_id || "") === o) ? "selected" : "";
        return `<option value="${o}" ${sel}>${label}</option>`;
      }).join("");

      const lockChecked = t.locked ? "checked" : "";
      tokenRows.push(`
        <div style="display:flex; gap:8px; align-items:center; margin:6px 0;">
          <div style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
            <span>${t.name || id}</span> <span style="opacity:.6">(${id.slice(0,8)})</span>
          </div>
          <select data-token-owner="${id}" style="padding:4px;">${opts}</select>
          <label style="font-size:12px;"><input type="checkbox" data-token-lock="${id}" ${lockChecked}> lock</label>
        </div>
      `);
    }
    tokenListEl.innerHTML = tokenRows.join("") || `<div style="opacity:.7">(no tokens)</div>`;

    tokenListEl.querySelectorAll("select[data-token-owner]").forEach((sel) => {
      sel.onchange = () => send("TOKEN_ASSIGN", { id: sel.getAttribute("data-token-owner"), owner_id: sel.value.trim() || null });
    });
    tokenListEl.querySelectorAll("input[data-token-lock]").forEach((chk) => {
      chk.onchange = () => send("TOKEN_SET_LOCK", { id: chk.getAttribute("data-token-lock"), locked: chk.checked });
    });

    const strokeRows = [];
    for (const [id, s] of state.strokes) {
      const lockChecked = s.locked ? "checked" : "";
      strokeRows.push(`<div style="display:flex; justify-content:space-between; margin:4px 0;"><span>${id.slice(0, 12)}</span><label style="font-size:12px;"><input type="checkbox" data-stroke-lock="${id}" ${lockChecked}> lock</label></div>`);
    }
    strokeListEl.innerHTML = strokeRows.join("") || `<div style="opacity:.7">(no strokes)</div>`;
    strokeListEl.querySelectorAll("input[data-stroke-lock]").forEach((chk) => {
      chk.onchange = () => send("STROKE_SET_LOCK", { id: chk.getAttribute("data-stroke-lock"), locked: chk.checked });
    });

    const shapeRows = [];
    for (const [id, s] of state.shapes) {
      const lockChecked = s.locked ? "checked" : "";
      shapeRows.push(`<div style="display:flex; justify-content:space-between; margin:4px 0;"><span>${s.type} ${id.slice(0, 12)}</span><label style="font-size:12px;"><input type="checkbox" data-shape-lock="${id}" ${lockChecked}> lock</label></div>`);
    }
    shapeListEl.innerHTML = shapeRows.join("") || `<div style="opacity:.7">(no shapes)</div>`;
    shapeListEl.querySelectorAll("input[data-shape-lock]").forEach((chk) => {
      chk.onchange = () => send("SHAPE_SET_LOCK", { id: chk.getAttribute("data-shape-lock"), locked: chk.checked });
    });
  }

  async function refreshRoomsPanel() {
    try {
      const data = await apiGet("/api/my/rooms");
      const rooms = data.rooms || [];
      const rows = rooms.map((r) => `
        <div style="display:flex; gap:8px; align-items:center; margin:4px 0;">
          <button data-open-room="${r.room_id}" style="padding:2px 6px;">Open</button>
          <button data-copy-join="${r.room_id}" style="padding:2px 6px;">Copy Join Link</button>
          <button data-rename-room="${r.room_id}" style="padding:2px 6px;">Rename</button>
          <button data-delete-room="${r.room_id}" style="padding:2px 6px; color:#ffb3b3;">Delete</button>
          <code>${r.room_id}</code>
          <span style="opacity:.9">${r.name}</span>
          <span style="opacity:.7">${r.role === "owner" ? "GM" : "Player"}</span>
          <span style="opacity:.6">${(r.join_code || "").trim() ? "join " + r.join_code : ""}</span>
          <span style="opacity:.6">${(r.created_at || "").replace("T", " ").slice(0, 19)}</span>
        </div>
      `);
      roomsListEl.innerHTML = rows.join("") || `<div style="opacity:.7">(no rooms)</div>`;
      roomsListEl.querySelectorAll("button[data-open-room]").forEach((btn) => {
        btn.onclick = () => switchRoom(btn.getAttribute("data-open-room"));
      });
      roomsListEl.querySelectorAll("button[data-copy-join]").forEach((btn) => {
        btn.onclick = async () => {
          const rid = btn.getAttribute("data-copy-join");
          const room = rooms.find((x) => x.room_id === rid);
          if (!room || !room.join_code) {
            log(`JOIN LINK ERROR: no join code for room ${rid}`);
            return;
          }
          const link = `${location.origin}/join/${room.join_code}`;
          try {
            await navigator.clipboard.writeText(link);
            log(`JOIN LINK COPIED ${room.join_code}`);
          } catch (e) {
            log(`JOIN LINK: ${link}`);
          }
        };
      });
      roomsListEl.querySelectorAll("button[data-rename-room]").forEach((btn) => {
        btn.onclick = async () => {
          const rid = btn.getAttribute("data-rename-room");
          const next = prompt("New room name?", "") || "";
          const name = next.trim();
          if (!name) return;
          try {
            await apiPatch(`/api/rooms/${encodeURIComponent(rid)}`, { name }, true);
            log(`ROOM RENAMED ${rid} -> ${name}`);
            await refreshRoomsPanel();
          } catch (e) {
            log(`RENAME ROOM ERROR: ${e.message || e}`);
          }
        };
      });
      roomsListEl.querySelectorAll("button[data-delete-room]").forEach((btn) => {
        btn.onclick = async () => {
          const rid = btn.getAttribute("data-delete-room");
          if (!confirm(`Delete room '${rid}'? This also deletes snapshots.`)) return;
          try {
            const url = apiUrl(`/api/rooms/${encodeURIComponent(rid)}`, true);
            const res = await fetch(url, { method: "DELETE" });
            if (!res.ok) throw new Error(await res.text());
            log(`ROOM DELETED ${rid}`);
            await refreshRoomsPanel();
            if (roomEl.value.trim() === rid) {
              roomEl.value = "";
              snapshotRoomLabelEl.textContent = "(none)";
              snapshotsListEl.innerHTML = `<div style="opacity:.7">(room deleted)</div>`;
            }
          } catch (e) {
            log(`DELETE ROOM ERROR: ${e.message || e}`);
          }
        };
      });
    } catch (e) {
      roomsListEl.innerHTML = `<div style="color:#ffb3b3">Rooms load failed</div>`;
      log(`ROOMS ERROR: ${e.message || e}`);
    }
  }

  async function refreshSnapshotsPanel() {
    const rid = roomEl.value.trim();
    snapshotRoomLabelEl.textContent = rid || "(none)";
    if (!rid) {
      snapshotsListEl.innerHTML = `<div style="opacity:.7">(enter room id)</div>`;
      return;
    }
    try {
      const data = await apiGet(`/api/rooms/${encodeURIComponent(rid)}/snapshots`);
      const snaps = data.snapshots || [];
      const rows = snaps.map((s) => `
        <div style="display:flex; gap:8px; align-items:center; margin:4px 0;">
          <button data-restore-snap="${s.snapshot_id}" style="padding:2px 6px;">Restore</button>
          <code>${s.snapshot_id}</code>
          <span style="opacity:.9">${s.label}</span>
          <span style="opacity:.6">${(s.created_at || "").replace("T", " ").slice(0, 19)}</span>
        </div>
      `);
      snapshotsListEl.innerHTML = rows.join("") || `<div style="opacity:.7">(no snapshots)</div>`;
      snapshotsListEl.querySelectorAll("button[data-restore-snap]").forEach((btn) => {
        btn.onclick = async () => {
          const sid = btn.getAttribute("data-restore-snap");
          try {
            await apiPost(`/api/rooms/${encodeURIComponent(rid)}/restore/${encodeURIComponent(sid)}`, {}, true);
            log(`RESTORED snapshot ${sid}`);
            await refreshSnapshotsPanel();
          } catch (e) {
            log(`RESTORE ERROR: ${e.message || e}`);
          }
        };
      });
    } catch (e) {
      snapshotsListEl.innerHTML = `<div style="color:#ffb3b3">Snapshots load failed</div>`;
      log(`SNAPSHOTS ERROR: ${e.message || e}`);
    }
  }

  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    requestRender();
  }
  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  function requestRender() { render(); }

  function screenToWorld(sx, sy) { return { x: (sx - cam.x) / cam.z, y: (sy - cam.y) / cam.z }; }
  function worldToScreen(wx, wy) { return { x: wx * cam.z + cam.x, y: wy * cam.z + cam.y }; }
  function snap(v) { return ui.snap ? Math.round(v / ui.gridSize) * ui.gridSize : v; }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function tokenRadiusWorld(token = null) {
    const s = clamp(Number(token?.size_scale ?? 1), 0.25, 4);
    return (ui.gridSize * s) / 2;
  }

  function hitTestToken(wx, wy) {
    let best = null;
    let bestD2 = Infinity;
    for (const [id, t] of state.tokens) {
      const r = tokenRadiusWorld(t);
      const dx = wx - t.x;
      const dy = wy - t.y;
      const d2 = dx * dx + dy * dy;
      if (d2 <= r * r && d2 < bestD2) { best = id; bestD2 = d2; }
    }
    return best;
  }

  function pointToSegmentDistance(wx, wy, x1, y1, x2, y2) {
    const vx = x2 - x1;
    const vy = y2 - y1;
    const len2 = vx * vx + vy * vy;
    if (len2 <= 0) return Math.hypot(wx - x1, wy - y1);
    let t = ((wx - x1) * vx + (wy - y1) * vy) / len2;
    t = clamp(t, 0, 1);
    const px = x1 + t * vx;
    const py = y1 + t * vy;
    return Math.hypot(wx - px, wy - py);
  }

  function shapeContainsPoint(sh, wx, wy) {
    const tol = Math.max(6 / cam.z, (sh.width || 3) * 0.8);
    if (sh.type === "line") {
      return pointToSegmentDistance(wx, wy, sh.x1, sh.y1, sh.x2, sh.y2) <= tol;
    }
    if (sh.type === "rect") {
      const minx = Math.min(sh.x1, sh.x2) - tol;
      const maxx = Math.max(sh.x1, sh.x2) + tol;
      const miny = Math.min(sh.y1, sh.y2) - tol;
      const maxy = Math.max(sh.y1, sh.y2) + tol;
      return wx >= minx && wx <= maxx && wy >= miny && wy <= maxy;
    }
    if (sh.type === "circle") {
      const r = Math.hypot(sh.x2 - sh.x1, sh.y2 - sh.y1);
      const d = Math.hypot(wx - sh.x1, wy - sh.y1);
      return d <= r + tol;
    }
    if (sh.type === "text") {
      const fs = clamp(Number(sh.font_size || 20), 8, 96);
      const txt = String(sh.text || "").trim() || "Text";
      const w = Math.max(fs, txt.length * fs * 0.6);
      const h = fs * 1.2;
      return wx >= sh.x1 - tol && wx <= sh.x1 + w + tol && wy >= sh.y1 - tol && wy <= sh.y1 + h + tol;
    }
    return false;
  }

  function hitTestShape(wx, wy) {
    const order = state.draw_order?.shapes || [];
    for (let i = order.length - 1; i >= 0; i--) {
      const id = order[i];
      const sh = state.shapes.get(id);
      if (!sh) continue;
      if (shapeContainsPoint(sh, wx, wy)) return id;
    }
    return null;
  }

  function updateHoveredToken(wx, wy) {
    const next = draggingTokenId || hitTestToken(wx, wy);
    if (next === hoveredTokenId) return;
    hoveredTokenId = next;
    requestRender();
  }

  function drawBackground() {
    if (state.background_mode === "terrain") {
      ensureTerrain(state.terrain_seed, state.terrain_style);
      drawTerrainBackground();
      return;
    }

    if (state.background_mode === "url" && bgImage) {
      const a = worldToScreen(0, 0);
      const b = worldToScreen(bgImage.naturalWidth, bgImage.naturalHeight);
      const w = b.x - a.x;
      const h = b.y - a.y;
      ctx.drawImage(bgImage, a.x, a.y, w, h);
    }

    if (state.background_mode === "url" && bgImageStatus === "loading") {
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.fillRect(12, 12, 140, 28);
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "12px ui-monospace, monospace";
      ctx.fillText("Loading background...", 20, 30);
      ctx.restore();
    } else if (state.background_mode === "url" && bgImageStatus === "error") {
      ctx.save();
      ctx.fillStyle = "rgba(120,0,0,0.55)";
      ctx.fillRect(12, 12, 180, 28);
      ctx.fillStyle = "rgba(255,240,240,0.95)";
      ctx.font = "12px ui-monospace, monospace";
      ctx.fillText("Background failed to load", 20, 30);
      ctx.restore();
    }
  }

  function drawGrid() {
    if (!ui.showGrid || !state.layer_visibility.grid) return;

    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const gs = ui.gridSize * cam.z;
    if (gs < 8) return;

    const topLeft = screenToWorld(0, 0);
    const botRight = screenToWorld(w, h);

    const startX = Math.floor(topLeft.x / ui.gridSize) * ui.gridSize;
    const endX = Math.ceil(botRight.x / ui.gridSize) * ui.gridSize;
    const startY = Math.floor(topLeft.y / ui.gridSize) * ui.gridSize;
    const endY = Math.ceil(botRight.y / ui.gridSize) * ui.gridSize;

    ctx.save();
    ctx.lineWidth = 1;
    const gridAlpha = state.background_mode === "terrain"
      ? 0.18
      : (state.background_mode === "url" ? 0.35 : 0.25);
    ctx.strokeStyle = `rgba(255,255,255,${gridAlpha})`;

    for (let x = startX; x <= endX; x += ui.gridSize) {
      const sx = worldToScreen(x, 0).x;
      ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, h); ctx.stroke();
    }
    for (let y = startY; y <= endY; y += ui.gridSize) {
      const sy = worldToScreen(0, y).y;
      ctx.beginPath(); ctx.moveTo(0, sy); ctx.lineTo(w, sy); ctx.stroke();
    }
    ctx.restore();
  }

  function drawStrokes() {
    if (!state.layer_visibility.drawings) return;
    for (const id of state.draw_order.strokes) {
      const s = state.strokes.get(id);
      if (!s) continue;
      if (!s.points || s.points.length < 2) continue;
      ctx.save();
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.strokeStyle = s.color || "#fff";
      ctx.lineWidth = (s.width || 3) * cam.z;
      ctx.beginPath();
      const p0 = worldToScreen(s.points[0].x, s.points[0].y);
      ctx.moveTo(p0.x, p0.y);
      for (let i = 1; i < s.points.length; i++) {
        const pi = worldToScreen(s.points[i].x, s.points[i].y);
        ctx.lineTo(pi.x, pi.y);
      }
      ctx.stroke();
      ctx.restore();
    }

    if (activeStroke && activeStroke.points.length >= 2) {
      ctx.save();
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.strokeStyle = activeStroke.color;
      ctx.lineWidth = activeStroke.width * cam.z;
      ctx.beginPath();
      const p0 = worldToScreen(activeStroke.points[0].x, activeStroke.points[0].y);
      ctx.moveTo(p0.x, p0.y);
      for (let i = 1; i < activeStroke.points.length; i++) {
        const pi = worldToScreen(activeStroke.points[i].x, activeStroke.points[i].y);
        ctx.lineTo(pi.x, pi.y);
      }
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawOneShape(sh, isPreview) {
    const a = worldToScreen(sh.x1, sh.y1);
    const b = worldToScreen(sh.x2, sh.y2);

    ctx.save();
    ctx.strokeStyle = sh.color || "#fff";
    ctx.lineWidth = (sh.width || 3) * cam.z;
    if (isPreview) ctx.setLineDash([8, 6]);

    if (sh.type === "line") {
      ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
      ctx.restore();
      return;
    }

    if (sh.type === "rect") {
      const left = Math.min(a.x, b.x);
      const top = Math.min(a.y, b.y);
      const w = Math.abs(a.x - b.x);
      const h = Math.abs(a.y - b.y);
      ctx.strokeRect(left, top, w, h);
      ctx.restore();
      return;
    }

    if (sh.type === "circle") {
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const r = Math.sqrt(dx * dx + dy * dy);
      ctx.beginPath(); ctx.arc(a.x, a.y, r, 0, Math.PI * 2); ctx.stroke();
      ctx.restore();
      return;
    }

    if (sh.type === "text") {
      const fontSize = clamp(Number(sh.font_size || 20), 8, 96) * cam.z;
      const text = String(sh.text || "").trim() || (isPreview ? "Text" : "");
      if (!text) {
        ctx.restore();
        return;
      }
      ctx.font = `${fontSize}px ui-monospace, monospace`;
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillStyle = sh.color || "#fff";
      ctx.fillText(text, a.x, a.y);
      ctx.restore();
      return;
    }

    ctx.restore();
  }

  function drawShapes() {
    if (!state.layer_visibility.shapes) return;
    for (const id of state.draw_order.shapes) {
      const sh = state.shapes.get(id);
      if (!sh) continue;
      drawOneShape(sh, false);
      if (id === selectedShapeId) {
        const a = worldToScreen(sh.x1, sh.y1);
        const b = worldToScreen(sh.x2, sh.y2);
        ctx.save();
        ctx.strokeStyle = "#00d1ff";
        ctx.lineWidth = Math.max(1.5, cam.z);
        if (sh.type === "text") {
          const fs = clamp(Number(sh.font_size || 20), 8, 96) * cam.z;
          const txt = String(sh.text || "").trim() || "Text";
          const w = Math.max(fs, txt.length * fs * 0.6);
          const h = fs * 1.2;
          ctx.strokeRect(a.x - 4, a.y - 4, w + 8, h + 8);
        } else {
          const left = Math.min(a.x, b.x) - 4;
          const top = Math.min(a.y, b.y) - 4;
          const w = Math.abs(a.x - b.x) + 8;
          const h = Math.abs(a.y - b.y) + 8;
          ctx.strokeRect(left, top, w, h);
        }
        ctx.restore();
      }
    }
    if (activeShapePreview) drawOneShape(activeShapePreview, true);
  }

  function drawTokenBadges(t, s, r) {
    const badges = normalizedBadgeList(t?.badges);
    if (!badges.length) return;
    const bubbleR = clamp(r * 0.28, 6, 12);
    const angles = [-Math.PI / 4, Math.PI / 4, (3 * Math.PI) / 4, (-3 * Math.PI) / 4];
    const visible = badges.slice(0, 4);

    for (let i = 0; i < visible.length; i++) {
      const meta = TOKEN_BADGE_BY_ID.get(visible[i]);
      if (!meta) continue;
      const a = angles[i];
      const bx = s.x + Math.cos(a) * (r - bubbleR * 0.2);
      const by = s.y + Math.sin(a) * (r - bubbleR * 0.2);
      ctx.save();
      ctx.beginPath();
      ctx.arc(bx, by, bubbleR, 0, Math.PI * 2);
      ctx.fillStyle = meta.color;
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.stroke();
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = `${Math.max(10, Math.floor(bubbleR * 1.35))}px system-ui, sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(meta.glyph, bx, by + 0.5);
      ctx.restore();
    }

    if (badges.length > 4) {
      const extra = badges.length - 4;
      const bx = s.x + (r - bubbleR * 0.2);
      const by = s.y;
      ctx.save();
      ctx.beginPath();
      ctx.arc(bx, by, bubbleR, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = `${Math.max(10, Math.floor(bubbleR * 1.1))}px system-ui, sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(`+${extra}`, bx, by + 0.5);
      ctx.restore();
    }
  }

  function drawTokens() {
    if (!state.layer_visibility.tokens) return;
    for (const [id, t] of state.tokens) {
      const s = worldToScreen(t.x, t.y);
      const r = tokenRadiusWorld(t) * cam.z;

      ctx.save();
      const imageDrawn = drawTokenImageClippedCircle(t, s, r);
      if (!imageDrawn) {
        ctx.beginPath();
        ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
        ctx.fillStyle = t.color || "#fff";
        ctx.fill();
      }
      ctx.lineWidth = Math.max(2, 2 * cam.z);
      ctx.strokeStyle = (id === selectedTokenId) ? "#00d1ff" : "rgba(255,255,255,0.45)";
      ctx.stroke();

      if (t.locked) {
        ctx.strokeStyle = "rgba(255,0,0,0.8)";
        ctx.lineWidth = Math.max(2, 2 * cam.z);
        ctx.stroke();
      }

      drawTokenBadges(t, s, r);

      const showLabel = id === selectedTokenId || id === hoveredTokenId;
      if (showLabel) {
        const label = (t.name || "Token").slice(0, 18);
        const fontSize = Math.max(14, 14 * cam.z);
        ctx.font = `700 ${fontSize}px system-ui, sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const metrics = ctx.measureText(label);
        const textWidth = metrics.width;
        const textHeight = fontSize;
        const padX = Math.max(8, 6 * cam.z);
        const padY = Math.max(4, 3 * cam.z);
        const boxW = textWidth + padX * 2;
        const boxH = textHeight + padY * 2;
        const boxX = s.x - boxW / 2;
        const boxY = s.y - boxH / 2;
        const radius = Math.max(8, boxH * 0.35);

        ctx.beginPath();
        ctx.roundRect(boxX, boxY, boxW, boxH, radius);
        ctx.fillStyle = "rgba(0,0,0,0.72)";
        ctx.fill();

        ctx.strokeStyle = "rgba(255,255,255,0.32)";
        ctx.lineWidth = Math.max(1, cam.z * 0.9);
        ctx.stroke();

        ctx.fillStyle = "#fff";
        ctx.fillText(label, s.x, s.y);
      }
      ctx.restore();
    }
  }

  function drawRuler() {
    if (!activeRuler) return;
    const a = worldToScreen(activeRuler.x1, activeRuler.y1);
    const b = worldToScreen(activeRuler.x2, activeRuler.y2);

    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 4]);
    ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
    ctx.setLineDash([]);

    const dx = activeRuler.x2 - activeRuler.x1;
    const dy = activeRuler.y2 - activeRuler.y1;
    const distWorld = Math.sqrt(dx * dx + dy * dy);
    const squares = distWorld / ui.gridSize;
    const feet = squares * ui.feetPerSq;

    const midx = (a.x + b.x) / 2;
    const midy = (a.y + b.y) / 2;

    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(midx - 90, midy - 14, 180, 28);
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.font = "12px ui-monospace, monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(`${squares.toFixed(2)} sq (${feet.toFixed(1)} ft)`, midx, midy);
    ctx.restore();
  }

  function drawDragSpawnGhost() {
    if (!dragSpawn || !dragSpawnWorld || !dragSpawnOverCanvas) return;
    const s = worldToScreen(dragSpawnWorld.x, dragSpawnWorld.y);
    const r = tokenRadiusWorld(dragSpawn) * cam.z;
    ctx.save();
    ctx.globalAlpha = 0.7;
    const imageDrawn = drawTokenImageClippedCircle({ image_url: dragSpawn.image_url }, s, r);
    if (!imageDrawn) {
      ctx.beginPath();
      ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
      ctx.fillStyle = dragSpawn.color || "#888";
      ctx.fill();
    }
    ctx.lineWidth = Math.max(2, 2 * cam.z);
    ctx.setLineDash([7, 5]);
    ctx.strokeStyle = "rgba(255,255,255,0.95)";
    ctx.beginPath();
    ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  function render() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    updateCanvasCursor();
    document.getElementById("spawn").classList.toggle("active", !!dragSpawn);
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = "#222";
    ctx.fillRect(0, 0, w, h);

    drawBackground();
    drawGrid();
    drawStrokes();
    drawShapes();
    drawTokens();
    drawDragSpawnGhost();
    drawRuler();
  }

  function send(type, payload = {}) {
    if (online && ws && ws.readyState === 1) {
      ws.send(JSON.stringify({ type, payload }));
      return;
    }
    applyLocalEvent(type, payload);
  }

  function makeId() {
    if (window.crypto && crypto.randomUUID) return crypto.randomUUID();
    return "id-" + Math.random().toString(16).slice(2) + "-" + Date.now().toString(16);
  }

  function applyStateSync(s) {
    // Cancel local in-progress interactions so authoritative sync wins cleanly.
    isPanning = false;
    pointerCaptured = false;
    draggingTokenId = null;
    dragSpawn = null;
    dragSpawnWorld = null;
    dragSpawnOverCanvas = false;
    activeStroke = null;
    activeShapePreview = null;
    activeRuler = null;

    state.room_id = s.room_id;
    state.gm_id = s.gm_id;
    state.allow_players_move = !!s.allow_players_move;
    state.allow_all_move = !!s.allow_all_move;
    state.lockdown = !!s.lockdown;
    applyBackgroundState(s.background_mode, s.background_url, s.terrain_seed, s.terrain_style);
    state.layer_visibility = {
      grid: s.layer_visibility?.grid ?? true,
      drawings: s.layer_visibility?.drawings ?? true,
      shapes: s.layer_visibility?.shapes ?? true,
      tokens: s.layer_visibility?.tokens ?? true,
    };
    state.version = s.version || 0;

    state.tokens.clear();
    for (const [id, t] of Object.entries(s.tokens || {})) {
      state.tokens.set(id, { ...t, badges: normalizedBadgeList(t?.badges) });
    }
    state.strokes.clear();
    for (const [id, st] of Object.entries(s.strokes || {})) state.strokes.set(id, st);
    state.shapes.clear();
    for (const [id, sh] of Object.entries(s.shapes || {})) state.shapes.set(id, sh);
    state.draw_order = {
      strokes: Array.isArray(s.draw_order?.strokes) ? s.draw_order.strokes.filter((id) => state.strokes.has(id)) : [],
      shapes: Array.isArray(s.draw_order?.shapes) ? s.draw_order.shapes.filter((id) => state.shapes.has(id)) : [],
    };
    for (const id of state.strokes.keys()) if (!state.draw_order.strokes.includes(id)) state.draw_order.strokes.push(id);
    for (const id of state.shapes.keys()) if (!state.draw_order.shapes.includes(id)) state.draw_order.shapes.push(id);

    if (selectedTokenId && !state.tokens.has(selectedTokenId)) selectedTokenId = null;
    if (selectedShapeId && !state.shapes.has(selectedShapeId)) selectedShapeId = null;
    if (hoveredTokenId && !state.tokens.has(hoveredTokenId)) hoveredTokenId = null;
    players.add(myId());
    if (state.gm_id) players.add(state.gm_id);
    refreshGmUI();
    requestRender();
  }

  function toPlainObjectMap(m) {
    const out = {};
    for (const [k, v] of m.entries()) out[k] = v;
    return out;
  }

  function currentStateSnapshot() {
    return {
      room_id: state.room_id || "offline",
      gm_id: state.gm_id || myId() || "player",
      allow_players_move: !!state.allow_players_move,
      allow_all_move: !!state.allow_all_move,
      lockdown: !!state.lockdown,
      background_mode: state.background_mode || "solid",
      background_url: state.background_url || null,
      terrain_seed: Number(state.terrain_seed || 1),
      terrain_style: state.terrain_style || "grassland",
      layer_visibility: { ...state.layer_visibility },
      version: Number(state.version || 0),
      tokens: toPlainObjectMap(state.tokens),
      strokes: toPlainObjectMap(state.strokes),
      shapes: toPlainObjectMap(state.shapes),
      draw_order: {
        strokes: [...(state.draw_order?.strokes || [])],
        shapes: [...(state.draw_order?.shapes || [])],
      },
    };
  }

  let offlineSaveTimer = null;
  let lastOfflineEraseHistoryAt = 0;
  const offlineHistory = [];
  const offlineFuture = [];
  const OFFLINE_HISTORY_LIMIT = 50;
  const OFFLINE_MUTATION_TYPES = new Set([
    "ROOM_SETTINGS", "TOKEN_CREATE", "TOKEN_DELETE", "TOKEN_ASSIGN", "TOKEN_RENAME", "TOKEN_SET_SIZE", "TOKEN_SET_LOCK",
    "TOKEN_BADGE_TOGGLE", "TOKEN_MOVE", "STROKE_ADD", "STROKE_DELETE", "STROKE_SET_LOCK", "ERASE_AT", "SHAPE_ADD", "SHAPE_UPDATE", "SHAPE_DELETE", "SHAPE_SET_LOCK",
  ]);

  function saveOfflineStateNow() {
    try {
      const payload = {
        state: currentStateSnapshot(),
        ui: {
          snap: !!snapEl.checked,
          showGrid: !!showGridEl.checked,
          gridSize: String(gridEl.value || "50"),
          feetPerSq: String(feetPerSqEl.value || "5"),
          color: String(colorEl.value || "#ffffff"),
          size: String(sizeEl.value || "3"),
          tool: String(toolEl.value || "move"),
          tokenSpawnScale: Number(ui.tokenSpawnScale || 1),
        },
      };
      localStorage.setItem(OFFLINE_STATE_KEY, JSON.stringify(payload));
    } catch (e) {}
  }

  function scheduleOfflineSave() {
    if (online) return;
    if (offlineSaveTimer) clearTimeout(offlineSaveTimer);
    offlineSaveTimer = setTimeout(() => {
      offlineSaveTimer = null;
      saveOfflineStateNow();
    }, 1000);
  }

  function pushOfflineHistory() {
    try {
      offlineHistory.push(JSON.stringify(currentStateSnapshot()));
      if (offlineHistory.length > OFFLINE_HISTORY_LIMIT) offlineHistory.shift();
      offlineFuture.length = 0;
    } catch (e) {}
  }

  function restoreOfflineState() {
    try {
      const raw = localStorage.getItem(OFFLINE_STATE_KEY);
      if (!raw) return false;
      const parsed = JSON.parse(raw);
      if (!parsed || !parsed.state) return false;
      applyStateSync(parsed.state);
      const uiState = parsed.ui || {};
      snapEl.checked = !!uiState.snap;
      showGridEl.checked = !!uiState.showGrid;
      gridEl.value = String(uiState.gridSize || gridEl.value || "50");
      feetPerSqEl.value = String(uiState.feetPerSq || feetPerSqEl.value || "5");
      colorEl.value = String(uiState.color || colorEl.value || "#ffffff");
      sizeEl.value = String(uiState.size || sizeEl.value || "3");
      if (typeof uiState.tokenSpawnScale === "number") ui.tokenSpawnScale = clamp(uiState.tokenSpawnScale, 0.25, 4);
      if (uiState.tool) toolEl.value = String(uiState.tool);
      refreshUI();
      refreshToolButtons();
      return true;
    } catch (e) {
      return false;
    }
  }

  function localStrokeHitsCircle(stroke, cx, cy, r) {
    const rr = r * r;
    for (const pt of (stroke.points || [])) {
      const dx = Number(pt.x || 0) - cx;
      const dy = Number(pt.y || 0) - cy;
      if (dx * dx + dy * dy <= rr) return true;
    }
    return false;
  }

  function localShapeHitsCircle(shape, cx, cy, r) {
    const rr = r * r;
    if (shape.type === "line") {
      const x1 = Number(shape.x1 || 0);
      const y1 = Number(shape.y1 || 0);
      const x2 = Number(shape.x2 || 0);
      const y2 = Number(shape.y2 || 0);
      const vx = x2 - x1;
      const vy = y2 - y1;
      const segLen2 = vx * vx + vy * vy;
      if (segLen2 === 0) {
        const dx = cx - x1;
        const dy = cy - y1;
        return dx * dx + dy * dy <= rr;
      }
      let t = ((cx - x1) * vx + (cy - y1) * vy) / segLen2;
      t = Math.max(0, Math.min(1, t));
      const px = x1 + t * vx;
      const py = y1 + t * vy;
      const dx = cx - px;
      const dy = cy - py;
      return dx * dx + dy * dy <= rr;
    }
    if (shape.type === "rect") {
      const minx = Math.min(Number(shape.x1 || 0), Number(shape.x2 || 0));
      const maxx = Math.max(Number(shape.x1 || 0), Number(shape.x2 || 0));
      const miny = Math.min(Number(shape.y1 || 0), Number(shape.y2 || 0));
      const maxy = Math.max(Number(shape.y1 || 0), Number(shape.y2 || 0));
      const dx = Math.max(minx - cx, 0, cx - maxx);
      const dy = Math.max(miny - cy, 0, cy - maxy);
      return dx * dx + dy * dy <= rr;
    }
    if (shape.type === "circle") {
      const ox = Number(shape.x1 || 0);
      const oy = Number(shape.y1 || 0);
      const rad = Math.hypot(Number(shape.x2 || 0) - ox, Number(shape.y2 || 0) - oy);
      const dist = Math.hypot(cx - ox, cy - oy);
      return dist <= rad + r;
    }
    if (shape.type === "text") {
      const ox = Number(shape.x1 || 0);
      const oy = Number(shape.y1 || 0);
      const fontSize = clamp(Number(shape.font_size || 20), 8, 96);
      const dist = Math.hypot(cx - ox, cy - oy);
      return dist <= r + Math.max(8, fontSize * 0.6);
    }
    return false;
  }

  function applyLocalEvent(type, payload = {}) {
    if (type === "UNDO") {
      if (!offlineHistory.length) return;
      try {
        offlineFuture.push(JSON.stringify(currentStateSnapshot()));
        const prev = offlineHistory.pop();
        applyStateSync(JSON.parse(prev));
      } catch (e) {}
      return;
    }
    if (type === "REDO") {
      if (!offlineFuture.length) return;
      try {
        offlineHistory.push(JSON.stringify(currentStateSnapshot()));
        const next = offlineFuture.pop();
        applyStateSync(JSON.parse(next));
      } catch (e) {}
      return;
    }

    if (OFFLINE_MUTATION_TYPES.has(type)) {
      if (type === "ERASE_AT") {
        const now = Date.now();
        if (now - lastOfflineEraseHistoryAt > 600) {
          lastOfflineEraseHistoryAt = now;
          pushOfflineHistory();
        }
      } else if (type !== "TOKEN_MOVE" || !!payload.commit) {
        pushOfflineHistory();
      }
    }

    if (type === "ROOM_SETTINGS") {
      if ("allow_players_move" in payload) state.allow_players_move = !!payload.allow_players_move;
      if ("allow_all_move" in payload) state.allow_all_move = !!payload.allow_all_move;
      if ("lockdown" in payload) state.lockdown = !!payload.lockdown;
      if ("background_mode" in payload || "background_url" in payload || "terrain_seed" in payload || "terrain_style" in payload) {
        applyBackgroundState(
          ("background_mode" in payload) ? payload.background_mode : state.background_mode,
          ("background_url" in payload) ? payload.background_url : state.background_url,
          ("terrain_seed" in payload) ? payload.terrain_seed : state.terrain_seed,
          ("terrain_style" in payload) ? payload.terrain_style : state.terrain_style,
        );
      }
      if ("layer_visibility" in payload && payload.layer_visibility) {
        state.layer_visibility = { ...state.layer_visibility, ...payload.layer_visibility };
      }
      refreshGmUI();
      requestRender();
      scheduleOfflineSave();
      return;
    }

    if (type === "TOKEN_DELETE") {
      state.tokens.delete(payload.id);
      if (selectedTokenId === payload.id) selectedTokenId = null;
      if (hoveredTokenId === payload.id) hoveredTokenId = null;
      refreshGmUI();
      requestRender();
      scheduleOfflineSave();
      return;
    }

    if (type === "TOKEN_MOVE") {
      const p = payload;
      const t = state.tokens.get(p.id);
      if (t) {
        t.x = Number(p.x ?? t.x);
        t.y = Number(p.y ?? t.y);
        state.tokens.set(p.id, t);
      }
      requestRender();
      scheduleOfflineSave();
      return;
    }

    if (type === "TOKEN_ASSIGN") {
      const t = state.tokens.get(payload.id);
      if (t) {
        t.owner_id = payload.owner_id ?? null;
        state.tokens.set(payload.id, t);
      }
      refreshGmUI();
      requestRender();
      scheduleOfflineSave();
      return;
    }

    if (type === "TOKEN_BADGE_TOGGLE") {
      const t = state.tokens.get(payload.id);
      if (t) {
        setTokenBadgeLocal(payload.id, payload.badge, payload.enabled ?? null);
      }
      refreshTokenMenuBadgeButtons();
      requestRender();
      scheduleOfflineSave();
      return;
    }

    if (type === "STROKE_ADD") {
      const p = payload;
      if (p?.id) {
        state.strokes.set(p.id, p);
        state.draw_order.strokes = state.draw_order.strokes.filter((id) => id !== p.id);
        state.draw_order.strokes.push(p.id);
      }
      refreshGmUI();
      requestRender();
      scheduleOfflineSave();
      return;
    }

    if (type === "STROKE_DELETE") {
      const ids = payload?.ids || [];
      for (const id of ids) {
        state.strokes.delete(id);
        state.draw_order.strokes = state.draw_order.strokes.filter((x) => x !== id);
      }
      refreshGmUI();
      requestRender();
      scheduleOfflineSave();
      return;
    }

    if (type === "SHAPE_ADD") {
      const p = payload;
      if (p?.id) {
        state.shapes.set(p.id, p);
        state.draw_order.shapes = state.draw_order.shapes.filter((id) => id !== p.id);
        state.draw_order.shapes.push(p.id);
      }
      refreshGmUI();
      requestRender();
      scheduleOfflineSave();
      return;
    }

    if (type === "SHAPE_UPDATE") {
      const p = payload;
      if (p?.id) {
        state.shapes.set(p.id, { ...(state.shapes.get(p.id) || {}), ...p });
        if (!state.draw_order.shapes.includes(p.id)) state.draw_order.shapes.push(p.id);
      }
      refreshGmUI();
      requestRender();
      scheduleOfflineSave();
      return;
    }

    if (type === "SHAPE_DELETE") {
      const sid = payload?.id;
      state.shapes.delete(sid);
      state.draw_order.shapes = state.draw_order.shapes.filter((x) => x !== sid);
      refreshGmUI();
      requestRender();
      scheduleOfflineSave();
      return;
    }

    if (type === "ERASE_AT") {
      const x = Number(payload.x || 0);
      const y = Number(payload.y || 0);
      const r = Math.max(1, Number(payload.r || 14));
      const strokeIds = [];
      const shapeIds = [];
      for (const [id, s] of state.strokes.entries()) {
        if (localStrokeHitsCircle(s, x, y, r)) strokeIds.push(id);
      }
      for (const [id, sh] of state.shapes.entries()) {
        if (localShapeHitsCircle(sh, x, y, r)) shapeIds.push(id);
      }
      for (const id of strokeIds) {
        state.strokes.delete(id);
        state.draw_order.strokes = state.draw_order.strokes.filter((v) => v !== id);
      }
      for (const id of shapeIds) {
        state.shapes.delete(id);
        state.draw_order.shapes = state.draw_order.shapes.filter((v) => v !== id);
      }
      if (strokeIds.length || shapeIds.length) {
        refreshGmUI();
        requestRender();
        scheduleOfflineSave();
      }
      return;
    }

    if (type === "TOKEN_CREATE") {
      const p = payload;
      if (p?.id) state.tokens.set(p.id, { ...(state.tokens.get(p.id) || {}), ...p, badges: normalizedBadgeList(p?.badges) });
      refreshGmUI();
      requestRender();
      scheduleOfflineSave();
      return;
    }
    if (type === "TOKEN_RENAME") {
      const p = payload;
      const t = state.tokens.get(p.id);
      if (t) {
        t.name = p.name || t.name;
        state.tokens.set(p.id, t);
      }
      refreshGmUI();
      requestRender();
      scheduleOfflineSave();
      return;
    }
    if (type === "TOKEN_SET_SIZE") {
      const p = payload;
      const t = state.tokens.get(p.id);
      if (t) {
        t.size_scale = clamp(Number(p.size_scale ?? t.size_scale ?? 1), 0.25, 4);
        state.tokens.set(p.id, t);
      }
      refreshGmUI();
      requestRender();
      scheduleOfflineSave();
      return;
    }
    if (type === "TOKEN_SET_LOCK") {
      const p = payload;
      const t = state.tokens.get(p.id);
      if (t) {
        t.locked = !!p.locked;
        state.tokens.set(p.id, t);
      }
      refreshGmUI();
      requestRender();
      scheduleOfflineSave();
      return;
    }
    if (type === "STROKE_SET_LOCK") {
      const p = payload;
      const s = state.strokes.get(p.id);
      if (s) {
        s.locked = !!p.locked;
        state.strokes.set(p.id, s);
      }
      refreshGmUI();
      requestRender();
      scheduleOfflineSave();
      return;
    }
    if (type === "SHAPE_SET_LOCK") {
      const p = payload;
      const s = state.shapes.get(p.id);
      if (s) {
        s.locked = !!p.locked;
        state.shapes.set(p.id, s);
      }
      refreshGmUI();
      requestRender();
      scheduleOfflineSave();
      return;
    }
  }

  function clearLocalRoomView() {
    state.room_id = null;
    state.background_mode = "solid";
    state.background_url = null;
    state.terrain_seed = 1;
    state.terrain_style = "grassland";
    bgImage = null;
    bgImageUrl = null;
    bgImageStatus = "idle";
    terrain.seed = null;
    terrain.gridSize = null;
    terrain.style = null;
    terrain.patternA = null;
    terrain.patternB = null;
    terrain.patternC = null;
    terrain.tileA = null;
    terrain.tileB = null;
    terrain.tileC = null;
    state.tokens.clear();
    state.strokes.clear();
    state.shapes.clear();
    state.draw_order = { strokes: [], shapes: [] };
    selectedTokenId = null;
    selectedShapeId = null;
    hoveredTokenId = null;
    draggingShapeId = null;
    shapeDragOrigin = null;
    dragSpawn = null;
    dragSpawnWorld = null;
    dragSpawnOverCanvas = false;
    requestRender();
  }

  function connectWS(force = false) {
    if (!appInitialized) {
      log("Connect deferred: app not initialized yet.");
      return;
    }

    if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
      if (!force) {
        log("Already connected.");
        return;
      }
      try { ws.close(); } catch {}
    }

    clearLocalRoomView();
    const room = encodeURIComponent(roomEl.value.trim());
    const cid = encodeURIComponent(cidEl.value.trim());
    const proto = (location.protocol === "https:") ? "wss" : "ws";
    const url = `${proto}://${location.host}/ws/${room}?client_id=${cid}`;

    const thisWs = new WebSocket(url);
    const thisSeq = ++wsConnectSeq;
    ws = thisWs;
    thisWs.onopen = () => {
      if (ws !== thisWs || thisSeq !== wsConnectSeq) return;
      online = true;
      hideResyncBadge();
      markInboundChange();
      seenInboundMutationSinceConnect = false;
      log(`connected: ${url}`);
      updateSessionPill();
      refreshSessionModalAuth();
      if (heartbeatTimer) clearInterval(heartbeatTimer);
      heartbeatTimer = setInterval(() => {
        if (ws === thisWs && thisWs.readyState === 1) send("HEARTBEAT", { ts: Date.now() });
      }, 10000);
    };
    thisWs.onclose = (ev) => {
      if (ws !== thisWs || thisSeq !== wsConnectSeq) return;
      ws = null;
      online = false;
      hideResyncBadge();
      seenInboundMutationSinceConnect = false;
      const reason = (ev && ev.reason) ? ` (${ev.reason})` : "";
      log(`disconnected (code ${ev.code})${reason}`);
      if (ev.code === 1008) {
        log("Connection rejected: login expired or you are not a member of this room.");
      }
      updateSessionPill();
      refreshSessionModalAuth();
      if (heartbeatTimer) {
        clearInterval(heartbeatTimer);
        heartbeatTimer = null;
      }
    };
    thisWs.onerror = () => {
      if (ws !== thisWs || thisSeq !== wsConnectSeq) return;
      log("ws error");
      updateSessionPill();
      refreshSessionModalAuth();
    };

    thisWs.onmessage = (msg) => {
      if (ws !== thisWs || thisSeq !== wsConnectSeq) return;
      let ev = null;
      try {
        ev = JSON.parse(msg.data);
      } catch (e) {
        console.error("WS parse failed", e, msg?.data);
        return;
      }
      try {
      if (STATE_CHANGE_EVENTS.has(ev.type)) markInboundChange();
      if (WATCHDOG_MUTATION_EVENTS.has(ev.type)) seenInboundMutationSinceConnect = true;

      if (ev.type === "STATE_SYNC") {
        hideResyncBadge();
        applyStateSync(ev.payload);
        log(`STATE_SYNC v${state.version} gm=${state.gm_id} strokes=${state.strokes.size} shapes=${state.shapes.size}`);
        updateSessionPill();
        refreshSessionModalAuth();
        return;
      }

      if (ev.type === "HELLO") {
        if (typeof ev.payload?.is_gm === "boolean") {
          log(ev.payload.is_gm ? "You are GM" : `GM is ${state.gm_id || "(unclaimed)"}`);
        }
        refreshGmUI();
        updateSessionPill();
        refreshSessionModalAuth();
        return;
      }

      if (ev.type === "HEARTBEAT") {
        return;
      }

      if (ev.type === "PRESENCE") {
        players.clear();
        for (const id of (ev.payload?.clients || [])) players.add(id);
        if (ev.payload?.gm_id) state.gm_id = ev.payload.gm_id;
        refreshGmUI();
        updateSessionPill();
        refreshSessionModalAuth();
        return;
      }

      if (ev.type === "ROOM_SETTINGS") {
        if ("allow_players_move" in ev.payload) state.allow_players_move = !!ev.payload.allow_players_move;
        if ("allow_all_move" in ev.payload) state.allow_all_move = !!ev.payload.allow_all_move;
        if ("lockdown" in ev.payload) state.lockdown = !!ev.payload.lockdown;
        if ("background_mode" in ev.payload || "background_url" in ev.payload || "terrain_seed" in ev.payload || "terrain_style" in ev.payload) {
          applyBackgroundState(
            ("background_mode" in ev.payload) ? ev.payload.background_mode : state.background_mode,
            ("background_url" in ev.payload) ? ev.payload.background_url : state.background_url,
            ("terrain_seed" in ev.payload) ? ev.payload.terrain_seed : state.terrain_seed,
            ("terrain_style" in ev.payload) ? ev.payload.terrain_style : state.terrain_style,
          );
        }
        if ("layer_visibility" in ev.payload && ev.payload.layer_visibility) {
          state.layer_visibility = { ...state.layer_visibility, ...ev.payload.layer_visibility };
        }
        refreshGmUI();
        requestRender();
        return;
      }

      if (ev.type === "TOKEN_CREATE") {
        const p = ev.payload;
        if (p?.id) state.tokens.set(p.id, { ...(state.tokens.get(p.id) || {}), ...p, badges: normalizedBadgeList(p?.badges) });
        refreshGmUI();
        requestRender();
        return;
      }

      if (ev.type === "TOKEN_MOVE") {
        const p = ev.payload;
        const t = state.tokens.get(p.id);
        if (t) {
          t.x = p.x;
          t.y = p.y;
          state.tokens.set(p.id, t);
          requestRender();
        }
        if (p.rejected) {
          if (draggingTokenId === p.id) draggingTokenId = null;
          log(`MOVE REJECTED for ${p.id}: ${p.reason}`);
        }
        return;
      }

      if (ev.type === "TOKEN_DELETE") {
        state.tokens.delete(ev.payload.id);
        if (selectedTokenId === ev.payload.id) selectedTokenId = null;
        if (hoveredTokenId === ev.payload.id) hoveredTokenId = null;
        refreshGmUI();
        requestRender();
        return;
      }

      if (ev.type === "TOKEN_ASSIGN") {
        const p = ev.payload;
        const t = state.tokens.get(p.id);
        if (t) {
          t.owner_id = p.owner_id ?? null;
          state.tokens.set(p.id, t);
        }
        refreshGmUI();
        requestRender();
        return;
      }

      if (ev.type === "TOKEN_RENAME") {
        const p = ev.payload;
        const t = state.tokens.get(p.id);
        if (t) {
          t.name = p.name || t.name;
          state.tokens.set(p.id, t);
        }
        refreshGmUI();
        requestRender();
        return;
      }

      if (ev.type === "TOKEN_SET_SIZE") {
        const p = ev.payload;
        const t = state.tokens.get(p.id);
        if (t) {
          t.size_scale = clamp(Number(p.size_scale ?? t.size_scale ?? 1), 0.25, 4);
          state.tokens.set(p.id, t);
        }
        refreshGmUI();
        requestRender();
        return;
      }

      if (ev.type === "TOKEN_SET_LOCK") {
        const p = ev.payload;
        const t = state.tokens.get(p.id);
        if (t) {
          t.locked = !!p.locked;
          state.tokens.set(p.id, t);
        }
        refreshGmUI();
        requestRender();
        return;
      }

      if (ev.type === "TOKEN_BADGE_TOGGLE") {
        const p = ev.payload;
        const t = state.tokens.get(p.id);
        if (t) {
          t.badges = normalizedBadgeList(p.badges);
          state.tokens.set(p.id, t);
        }
        refreshTokenMenuBadgeButtons();
        requestRender();
        return;
      }

      if (ev.type === "STROKE_ADD") {
        const p = ev.payload;
        if (p?.id) {
          state.strokes.set(p.id, p);
          state.draw_order.strokes = state.draw_order.strokes.filter((id) => id !== p.id);
          state.draw_order.strokes.push(p.id);
        }
        refreshGmUI();
        requestRender();
        return;
      }

      if (ev.type === "STROKE_DELETE") {
        const ids = ev.payload?.ids || [];
        for (const id of ids) {
          state.strokes.delete(id);
          state.draw_order.strokes = state.draw_order.strokes.filter((x) => x !== id);
        }
        refreshGmUI();
        requestRender();
        return;
      }

      if (ev.type === "STROKE_SET_LOCK") {
        const p = ev.payload;
        const s = state.strokes.get(p.id);
        if (s) {
          s.locked = !!p.locked;
          state.strokes.set(p.id, s);
        }
        refreshGmUI();
        requestRender();
        return;
      }

      if (ev.type === "ERASE_AT") {
        const strokeIds = ev.payload?.stroke_ids || [];
        const shapeIds = ev.payload?.shape_ids || [];
        for (const id of strokeIds) {
          state.strokes.delete(id);
          state.draw_order.strokes = state.draw_order.strokes.filter((x) => x !== id);
        }
        for (const id of shapeIds) {
          state.shapes.delete(id);
          state.draw_order.shapes = state.draw_order.shapes.filter((x) => x !== id);
        }
        if (strokeIds.length || shapeIds.length) {
          refreshGmUI();
          requestRender();
        }
        return;
      }

      if (ev.type === "SHAPE_ADD") {
        const p = ev.payload;
        if (p?.id) {
          state.shapes.set(p.id, p);
          state.draw_order.shapes = state.draw_order.shapes.filter((id) => id !== p.id);
          state.draw_order.shapes.push(p.id);
        }
        refreshGmUI();
        requestRender();
        return;
      }

      if (ev.type === "SHAPE_UPDATE") {
        const p = ev.payload;
        if (p?.id) {
          state.shapes.set(p.id, { ...(state.shapes.get(p.id) || {}), ...p });
          if (!state.draw_order.shapes.includes(p.id)) state.draw_order.shapes.push(p.id);
        }
        refreshGmUI();
        requestRender();
        return;
      }

      if (ev.type === "SHAPE_DELETE") {
        const sid = ev.payload?.id;
        state.shapes.delete(sid);
        state.draw_order.shapes = state.draw_order.shapes.filter((x) => x !== sid);
        refreshGmUI();
        requestRender();
        return;
      }

      if (ev.type === "SHAPE_SET_LOCK") {
        const p = ev.payload;
        const s = state.shapes.get(p.id);
        if (s) {
          s.locked = !!p.locked;
          state.shapes.set(p.id, s);
        }
        refreshGmUI();
        requestRender();
        return;
      }

      if (ev.type === "ERROR") {
        log(`ERROR: ${ev.payload.message}`);
        return;
      }
      } catch (e) {
        console.error("WS dispatch failed", ev, e);
      }
    };

    refreshSnapshotsPanel();
  }

  async function switchRoom(newRoomId) {
    roomEl.value = newRoomId;
    snapshotRoomLabelEl.textContent = newRoomId;
    await refreshSnapshotsPanel();
    connectWS(true);
  }

  document.getElementById("connect").onclick = () => connectWS(false);

  document.getElementById("spawn").onclick = () => {
    dragSpawn = {
      name: "Token",
      color: "#" + Math.floor(Math.random() * 16777215).toString(16).padStart(6, "0"),
      image_url: null,
      size_scale: ui.tokenSpawnScale,
    };
    dragSpawnWorld = null;
    dragSpawnOverCanvas = false;
    updateCanvasCursor();
    requestRender();
  };

  document.getElementById("undo").onclick = () => send("UNDO", {});
  document.getElementById("redo").onclick = () => send("REDO", {});

  drawerToggle.onclick = () => drawer.classList.toggle("hidden");
  drawerClose.onclick = () => drawer.classList.add("hidden");
  document.querySelectorAll(".tab-btn").forEach((btn) => {
    btn.addEventListener("click", () => activateDrawerTab(btn.dataset.tab, true));
  });
  try {
    mountDrawerPanels();
  } catch (e) {
    console.error("mountDrawerPanels failed", e);
    log(`UI INIT ERROR: ${e?.message || e}`);
  }
  [toolBtnMove, toolBtnPen, toolBtnShape, toolBtnText, toolBtnErase, toolBtnRuler].forEach((btn) => {
    if (!btn) return;
    btn.onclick = () => setTool(btn.dataset.tool);
    btn.addEventListener("mouseenter", () => showTooltipFor(btn));
    btn.addEventListener("mouseleave", hideTooltip);
  });
  window.addEventListener("error", (e) => {
    const msg = e?.message || "unknown";
    log(`JS ERROR: ${msg}`);
  });
  window.addEventListener("unhandledrejection", (e) => {
    const msg = e?.reason?.message || String(e?.reason || "unknown");
    log(`PROMISE ERROR: ${msg}`);
  });
  [document.getElementById("spawn"), document.getElementById("undo"), document.getElementById("redo")].forEach((btn) => {
    if (!btn) return;
    btn.addEventListener("mouseenter", () => showTooltipFor(btn));
    btn.addEventListener("mouseleave", hideTooltip);
  });
  sessionPill.addEventListener("click", openSessionModal);
  if (logToggleEl && logWrapEl) {
    logToggleEl.addEventListener("click", () => {
      setLogCollapsed(!logWrapEl.classList.contains("collapsed"));
    });
  }
  sessionModalClose.addEventListener("click", closeSessionModal);
  sessionModalBackdrop.addEventListener("click", closeSessionModal);
  sessionLoginBtn.addEventListener("click", async () => {
    const username = sessionAuthUserEl.value.trim();
    const password = sessionAuthPassEl.value;
    if (!username || !password) {
      log("LOGIN ERROR: username and password required");
      return;
    }
    try {
      await apiPost("/api/auth/login", { username, password });
      const user = await loadMe();
      if (user?.username) {
        log(`Logged in as ${user.username}`);
        refreshSessionModalAuth();
        updateSessionPill();
      }
    } catch (e) {
      log(`LOGIN ERROR: ${e.message || e}`);
    }
  });
  sessionRegisterBtn.addEventListener("click", async () => {
    const username = sessionAuthUserEl.value.trim();
    const password = sessionAuthPassEl.value;
    if (!username || !password) {
      log("REGISTER ERROR: username and password required");
      return;
    }
    try {
      await apiPost("/api/auth/register", { username, password });
      const user = await loadMe();
      if (user?.username) {
        log(`Registered and logged in as ${user.username}`);
        refreshSessionModalAuth();
        updateSessionPill();
      }
    } catch (e) {
      log(`REGISTER ERROR: ${e.message || e}`);
    }
  });
  sessionOpenLobbyBtn.addEventListener("click", () => {
    location.href = "/static/app.html";
  });
  sessionLogoutBtn.addEventListener("click", async () => {
    try {
      await apiPost("/api/auth/logout", {});
    } catch (e) {}
    setAuthIdentity(null);
    online = false;
    if (ws && ws.readyState === 1) {
      try { ws.close(); } catch {}
    }
    ensureOfflineGm();
    refreshSessionModalAuth();
    updateSessionPill();
  });
  sessionConnectBtn.addEventListener("click", () => {
    roomEl.value = sessionRoomEl.value.trim() || "demo";
    if (!me || !me.username) {
      log("Connect blocked: log in first.");
      return;
    }
    cidEl.value = me.username;
    connectWS(true);
    closeSessionModal();
  });
  sessionDisconnectBtn.addEventListener("click", () => {
    if (ws && ws.readyState === 1) {
      try { ws.close(); } catch {}
    }
  });
  [sessionRoomEl, sessionClientEl].forEach((inp) => {
    inp.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        if (me && me.username) sessionConnectBtn.click();
        else sessionLoginBtn.click();
      }
    });
  });
  updateSessionPill();
  setLogCollapsed(false);
  refreshToolButtons();
  updateCanvasCursor();
  (async () => {
    try {
      await loadMe();
      if (!restoreOfflineState()) {
        applyStateSync(currentStateSnapshot());
      }
      ensureOfflineGm();
      refreshSessionModalAuth();
      updateSessionPill();
      saveOfflineStateNow();
      ensureStaleWatchdog();
    } finally {
      appInitialized = true;
    }
  })();
  toolColorPicker.addEventListener("input", () => {
    colorEl.value = toolColorPicker.value;
    refreshToolContextChecks();
  });
  toolSizeSlider.addEventListener("input", () => {
    const next = clamp(Number(toolSizeSlider.value || "3"), 1, 30);
    sizeEl.value = String(Math.round(next));
    toolSizeValue.textContent = String(Math.round(next));
    refreshToolContextChecks();
  });
  mapCtx.addEventListener("mousemove", (e) => {
    const row = e.target.closest(".ctx-item.has-sub");
    if (!row) {
      scheduleCtxSubHide(120);
      return;
    }
    clearCtxSubHideTimer();
    hideCtxSubs();
    const sub = row.dataset.sub;
    if (sub === "bg") showSubMenu(mapCtxBg, row);
    if (sub === "layers") showSubMenu(mapCtxLayers, row);
    if (sub === "clear") showSubMenu(mapCtxClear, row);
  });
  mapCtx.addEventListener("mouseleave", () => scheduleCtxSubHide(120));
  [mapCtxBg, mapCtxLayers, mapCtxClear].forEach((sub) => {
    sub.addEventListener("mouseenter", () => clearCtxSubHideTimer());
    sub.addEventListener("mouseleave", () => scheduleCtxSubHide(120));
  });
  for (const m of allCtxMenus) {
    m.addEventListener("click", (e) => {
      const item = e.target.closest(".ctx-item");
      if (!item) return;
      const action = item.dataset.action;
      if (!action) return;
      hideAllCtx();
      handleCtxAction(action);
    });
  }
  window.addEventListener("mousedown", (e) => {
    if (!isClickInsideAnyCtxMenu(e.target)) hideAllCtx();
    if (!isClickInsideToolPanel(e.target)) hideToolPanels();
    hideTooltip();
  });

  document.getElementById("gmPanelBtn").onclick = () => {
    activateDrawerTab("players", true);
    refreshGmUI();
  };
  document.getElementById("gmPanelClose").onclick = () => { drawer.classList.add("hidden"); };
  document.getElementById("roomsPanelBtn").onclick = async () => {
    activateDrawerTab("rooms", true);
    await refreshRoomsPanel();
    await refreshSnapshotsPanel();
  };
  document.getElementById("roomsPanelClose").onclick = () => { drawer.classList.add("hidden"); };
  document.getElementById("libraryPanelBtn").onclick = async () => {
    activateDrawerTab("tokens", true);
    await refreshPacks();
  };
  document.getElementById("libraryPanelClose").onclick = () => { drawer.classList.add("hidden"); };
  document.getElementById("refreshPacksBtn").onclick = () => refreshPacks();
  packSelectEl.addEventListener("change", async () => {
    packState.selectedPackId = packSelectEl.value;
    await loadPack(packState.selectedPackId);
  });
  packSearchEl.addEventListener("input", () => {
    packState.search = packSearchEl.value || "";
    renderPackGrid();
  });
  Object.entries(sizePresetButtons).forEach(([scaleRaw, btn]) => {
    if (!btn) return;
    btn.onclick = () => applyTokenSizePreset(parseFloat(scaleRaw));
  });
  applyTokenSizePreset(ui.tokenSpawnScale);

  document.getElementById("tokenMenuRename").onclick = () => {
    if (!tokenMenuTokenId || !isGM()) return;
    const t = state.tokens.get(tokenMenuTokenId);
    if (!t) return;
    const next = (prompt("Rename token", t.name || "Token") || "").trim();
    if (!next) return;
    if (online) {
      t.name = next;
      state.tokens.set(tokenMenuTokenId, t);
    }
    send("TOKEN_RENAME", { id: tokenMenuTokenId, name: next });
    closeTokenMenu();
    if (online) {
      refreshGmUI();
      requestRender();
    }
  };
  document.getElementById("tokenMenuResize").onclick = () => {
    if (!tokenMenuTokenId || !isGM()) return;
    const t = state.tokens.get(tokenMenuTokenId);
    if (!t) return;
    const raw = prompt("Size multiplier (0.25 - 4.0)", String(t.size_scale ?? 1));
    if (raw == null) return;
    const next = clamp(parseFloat(raw), 0.25, 4);
    if (!Number.isFinite(next)) return;
    if (online) {
      t.size_scale = next;
      state.tokens.set(tokenMenuTokenId, t);
    }
    send("TOKEN_SET_SIZE", { id: tokenMenuTokenId, size_scale: next });
    closeTokenMenu();
    if (online) {
      refreshGmUI();
      requestRender();
    }
  };
  document.getElementById("tokenMenuAssign").onclick = () => {
    if (!tokenMenuTokenId || !isGM()) return;
    const arr = Array.from(players).sort();
    const t = state.tokens.get(tokenMenuTokenId);
    if (!t) return;
    const current = t.owner_id || "";
    const hint = arr.length ? `Available: ${arr.join(", ")}` : "No connected players";
    const raw = prompt(`Assign owner client_id (blank for unassigned)\n${hint}`, current);
    if (raw == null) return;
    const owner = raw.trim() || null;
    send("TOKEN_ASSIGN", { id: tokenMenuTokenId, owner_id: owner });
    closeTokenMenu();
  };
  document.getElementById("tokenMenuLock").onclick = () => {
    if (!tokenMenuTokenId || !isGM()) return;
    const t = state.tokens.get(tokenMenuTokenId);
    if (!t) return;
    const next = !t.locked;
    if (online) {
      t.locked = next;
      state.tokens.set(tokenMenuTokenId, t);
    }
    send("TOKEN_SET_LOCK", { id: tokenMenuTokenId, locked: next });
    closeTokenMenu();
    if (online) {
      refreshGmUI();
      requestRender();
    }
  };
  for (const badge of TOKEN_BADGES) {
    const btn = document.getElementById(badge.menuId);
    if (!btn) continue;
    btn.onclick = () => {
      if (!tokenMenuTokenId || !isGM()) return;
      if (online) {
        setTokenBadgeLocal(tokenMenuTokenId, badge.id, null);
        refreshTokenMenuBadgeButtons();
        requestRender();
      }
      sendTokenBadgeToggle(tokenMenuTokenId, badge.id, null);
    };
  }
  document.getElementById("tokenMenuBadgeClear").onclick = () => {
    if (!tokenMenuTokenId || !isGM()) return;
    const t = state.tokens.get(tokenMenuTokenId);
    if (!t) return;
    const ids = normalizedBadgeList(t.badges);
    if (!ids.length) return;
    for (const badgeId of ids) {
      if (online) setTokenBadgeLocal(tokenMenuTokenId, badgeId, false);
      sendTokenBadgeToggle(tokenMenuTokenId, badgeId, false);
    }
    if (online) {
      refreshTokenMenuBadgeButtons();
      requestRender();
    }
  };
  document.getElementById("tokenMenuDelete").onclick = () => {
    if (!tokenMenuTokenId || !isGM()) return;
    send("TOKEN_DELETE", { id: tokenMenuTokenId });
    closeTokenMenu();
  };
  window.addEventListener("pointerdown", (e) => {
    if (tokenMenuEl.style.display !== "block") return;
    if (tokenMenuEl.contains(e.target)) return;
    closeTokenMenu();
  });
  document.getElementById("refreshRoomsBtn").onclick = () => refreshRoomsPanel();
  document.getElementById("refreshSnapshotsBtn").onclick = () => refreshSnapshotsPanel();
  document.getElementById("createRoomBtn").onclick = async () => {
    const name = newRoomNameEl.value.trim();
    const roomId = newRoomIdEl.value.trim();
    try {
      const created = await apiPost("/api/rooms", { name, room_id: roomId });
      log(`ROOM CREATED ${created.room_id}`);
      if (created.room_id) await switchRoom(created.room_id);
      await refreshRoomsPanel();
      await refreshSnapshotsPanel();
    } catch (e) {
      log(`CREATE ROOM ERROR: ${e.message || e}`);
    }
  };
  document.getElementById("saveSnapshotBtn").onclick = async () => {
    const rid = roomEl.value.trim();
    if (!rid) {
      log("SAVE POINT ERROR: room id required");
      return;
    }
    const label = snapshotLabelInputEl.value.trim();
    try {
      const snap = await apiPost(`/api/rooms/${encodeURIComponent(rid)}/snapshots`, { label }, true);
      log(`SAVE POINT ${snap.snapshot_id}`);
      await refreshSnapshotsPanel();
    } catch (e) {
      log(`SAVE POINT ERROR: ${e.message || e}`);
    }
  };
  roomEl.addEventListener("change", () => {
    snapshotRoomLabelEl.textContent = roomEl.value.trim();
    refreshSnapshotsPanel();
  });

  allowPlayersMoveEl.addEventListener("change", (e) => send("ROOM_SETTINGS", { allow_players_move: e.target.checked }));
  allowAllMoveEl.addEventListener("change", (e) => send("ROOM_SETTINGS", { allow_all_move: e.target.checked }));
  lockdownEl.addEventListener("change", (e) => send("ROOM_SETTINGS", { lockdown: e.target.checked }));
  document.getElementById("setBg").addEventListener("click", () => {
    const nextUrl = bgUrlEl.value.trim() || null;
    send("ROOM_SETTINGS", {
      background_url: nextUrl,
      background_mode: nextUrl ? "url" : "solid",
    });
  });
  terrainBgEl.addEventListener("change", (e) => {
    if (e.target.checked) {
      send("ROOM_SETTINGS", { background_mode: "terrain", terrain_style: terrainStyleEl.value });
      return;
    }
    const nextUrl = (state.background_url || "").trim() || null;
    send("ROOM_SETTINGS", { background_mode: nextUrl ? "url" : "solid" });
  });
  terrainStyleEl.addEventListener("change", () => {
    send("ROOM_SETTINGS", { background_mode: "terrain", terrain_style: terrainStyleEl.value });
  });
  regenTerrainEl.addEventListener("click", () => {
    send("ROOM_SETTINGS", { background_mode: "terrain", terrain_seed: randomTerrainSeed(), terrain_style: terrainStyleEl.value });
  });

  function sendLayerVisibility() {
    send("ROOM_SETTINGS", {
      layer_visibility: {
        grid: layerGridEl.checked,
        drawings: layerDrawEl.checked,
        shapes: layerShapesEl.checked,
        tokens: layerTokensEl.checked,
      },
    });
  }
  layerGridEl.addEventListener("change", sendLayerVisibility);
  layerDrawEl.addEventListener("change", sendLayerVisibility);
  layerShapesEl.addEventListener("change", sendLayerVisibility);
  layerTokensEl.addEventListener("change", sendLayerVisibility);

  function refreshUI() {
    ui.snap = !!snapEl.checked;
    ui.gridSize = clamp(parseInt(gridEl.value || "50", 10), 10, 300);
    ui.showGrid = !!showGridEl.checked;
    ui.feetPerSq = clamp(parseFloat(feetPerSqEl.value || "5"), 1, 100);
    requestRender();
    scheduleOfflineSave();
  }
  snapEl.addEventListener("change", refreshUI);
  showGridEl.addEventListener("change", refreshUI);
  gridEl.addEventListener("change", refreshUI);
  feetPerSqEl.addEventListener("change", refreshUI);
  refreshUI();
  refreshGmUI();
  snapshotRoomLabelEl.textContent = roomEl.value.trim();
  refreshPacks();

  function tool() { return toolEl.value; }
  function isShapeTool(v) { return v === "rect" || v === "circle" || v === "line"; }
  function refreshToolButtons() {
    const t = tool();
    toolBtnMove.classList.toggle("active", t === "move");
    toolBtnPen.classList.toggle("active", t === "pen");
    toolBtnShape.classList.toggle("active", isShapeTool(t));
    toolBtnText.classList.toggle("active", t === "text");
    toolBtnErase.classList.toggle("active", t === "eraser");
    toolBtnRuler.classList.toggle("active", t === "ruler");
  }
  function setTool(next) {
    const prev = tool();
    if (next === "shape") {
      toolEl.value = isShapeTool(toolEl.value) ? toolEl.value : lastShapeTool;
    } else {
      toolEl.value = next;
      if (isShapeTool(next)) lastShapeTool = next;
    }
    const current = tool();
    if (current !== prev) {
      if (current === "move") flashToolActivate(toolBtnMove);
      else if (current === "pen") flashToolActivate(toolBtnPen);
      else if (isShapeTool(current)) flashToolActivate(toolBtnShape);
      else if (current === "text") flashToolActivate(toolBtnText);
      else if (current === "eraser") flashToolActivate(toolBtnErase);
      else if (current === "ruler") flashToolActivate(toolBtnRuler);
    }
    refreshToolButtons();
    updateCanvasCursor();
    scheduleOfflineSave();
  }
  function brushColor() { return colorEl.value; }
  function brushSize() { return clamp(parseFloat(sizeEl.value || "3"), 1, 30); }

  window.addEventListener("keydown", (e) => {
    if (e.key === "Shift") isShiftDown = true;
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
    const isTyping = tag === "input" || tag === "textarea" || tag === "select" || (e.target && e.target.isContentEditable);
    if (e.key === "Escape" && !sessionModal.classList.contains("hidden")) {
      closeSessionModal();
      return;
    }
    if (!isTyping) {
      const k = e.key.toLowerCase();
      if (k === "v") { setTool("move"); e.preventDefault(); return; }
      if (k === "p") { setTool("pen"); e.preventDefault(); return; }
      if (k === "s") { setTool("shape"); e.preventDefault(); return; }
      if (k === "t") { setTool("text"); e.preventDefault(); return; }
      if (k === "e") { setTool("eraser"); e.preventDefault(); return; }
      if (k === "r") { setTool("ruler"); e.preventDefault(); return; }
    }
    if (e.key === "Tab" && !isTyping) {
      e.preventDefault();
      drawer.classList.toggle("hidden");
      return;
    }
    if (e.key === "Escape") {
      hideAllCtx();
      hideToolPanels();
      hideTooltip();
    }
    if (e.key === "Escape" && tokenMenuEl.style.display === "block") {
      closeTokenMenu();
      return;
    }
    if (e.key === "Escape" && dragSpawn) {
      dragSpawn = null;
      dragSpawnWorld = null;
      dragSpawnOverCanvas = false;
      requestRender();
      return;
    }
    if (!isTyping && e.key.toLowerCase() === "d" && selectedTokenId && isGM()) {
      if (online) {
        setTokenBadgeLocal(selectedTokenId, "downed", null);
        refreshTokenMenuBadgeButtons();
        requestRender();
      }
      sendTokenBadgeToggle(selectedTokenId, "downed", null);
      e.preventDefault();
      return;
    }
    if ((e.key === "Delete" || e.key === "Backspace") && selectedTokenId && isGM()) {
      send("TOKEN_DELETE", { id: selectedTokenId });
      e.preventDefault();
    }
  });
  window.addEventListener("keyup", (e) => {
    if (e.key === "Shift") isShiftDown = false;
  });

  canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const oldZ = cam.z;
    const zoomFactor = (e.deltaY < 0) ? 1.12 : 0.89;
    const newZ = clamp(cam.z * zoomFactor, 0.25, 3);

    const wx = (mx - cam.x) / oldZ;
    const wy = (my - cam.y) / oldZ;
    cam.z = newZ;
    cam.x = mx - wx * newZ;
    cam.y = my - wy * newZ;
    requestRender();
  }, { passive: false });

  canvas.addEventListener("contextmenu", (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    const wpos = screenToWorld(sx, sy);
    const hit = hitTestToken(wpos.x, wpos.y);
    if (hit) {
      if (isGM()) {
        hideAllCtx();
        selectedTokenId = hit;
        openTokenMenu(hit, e.clientX, e.clientY);
        refreshGmUI();
        requestRender();
      } else {
        hideAllCtx();
        closeTokenMenu();
      }
      return;
    }
    const shapeHit = hitTestShape(wpos.x, wpos.y);
    if (shapeHit) {
      selectedShapeId = shapeHit;
      selectedTokenId = null;
      const sh = state.shapes.get(shapeHit);
      if (sh && isGM()) {
        if (sh.type === "text") {
          const nextText = prompt("Edit text:", String(sh.text || ""));
          if (nextText !== null) {
            const trimmed = nextText.trim();
            if (trimmed) send("SHAPE_UPDATE", { id: shapeHit, text: trimmed, commit: true });
          }
        }
        const nextColor = prompt("Shape color (#rrggbb):", String(sh.color || "#ffffff"));
        if (nextColor !== null && nextColor.trim()) {
          send("SHAPE_UPDATE", { id: shapeHit, color: nextColor.trim(), commit: true });
        }
      }
      requestRender();
      return;
    }
    closeTokenMenu();
    const t = tool();
    if (t === "pen") {
      showContextMenu(penCtx, e.clientX, e.clientY);
      return;
    }
    if (t === "rect" || t === "circle" || t === "line") {
      showContextMenu(shapeCtx, e.clientX, e.clientY);
      return;
    }
    if (t === "ruler") {
      showContextMenu(rulerCtx, e.clientX, e.clientY);
      return;
    }
    mapCtxWorld = { x: wpos.x, y: wpos.y };
    showMapMenu(e.clientX, e.clientY);
  });

  canvas.addEventListener("pointerdown", (e) => {
    closeTokenMenu();
    hideAllCtx();
    hideToolPanels();
    canvas.setPointerCapture(e.pointerId);
    pointerCaptured = true;

    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    const wpos = screenToWorld(sx, sy);

    if (dragSpawn && e.button === 0) {
      dragSpawnWorld = { x: wpos.x, y: wpos.y };
      dragSpawnOverCanvas = true;
      requestRender();
      return;
    }

    if (e.button === 2) {
      if (isGM()) {
        const hit = hitTestToken(wpos.x, wpos.y);
        if (hit) {
          selectedTokenId = hit;
          openTokenMenu(hit, e.clientX, e.clientY);
          refreshGmUI();
          requestRender();
          return;
        }
      }
      isPanning = true;
      panStart = { sx: e.clientX, sy: e.clientY, camX: cam.x, camY: cam.y };
      return;
    }

    erasingActive = false;
    lastEraseWorld = null;
    const t = tool();

    if (t === "move") {
      const hit = hitTestToken(wpos.x, wpos.y);
      const shapeHit = hit ? null : hitTestShape(wpos.x, wpos.y);
      selectedTokenId = hit;
      selectedShapeId = shapeHit;
      if (hit) {
        draggingTokenId = hit;
        draggingShapeId = null;
        shapeDragOrigin = null;
        const tok = state.tokens.get(hit);
        dragOffset.x = wpos.x - tok.x;
        dragOffset.y = wpos.y - tok.y;
      } else if (shapeHit && isGM()) {
        draggingShapeId = shapeHit;
        draggingTokenId = null;
        const sh = state.shapes.get(shapeHit);
        if (sh) {
          shapeDragOrigin = { wx: wpos.x, wy: wpos.y, x1: sh.x1, y1: sh.y1, x2: sh.x2, y2: sh.y2 };
        }
      }
      requestRender();
      return;
    }

    if (t === "pen") {
      activeStroke = { id: makeId(), points: [{ x: wpos.x, y: wpos.y }], color: brushColor(), width: brushSize(), locked: false, layer: "draw" };
      requestRender();
      return;
    }

    if (t === "eraser") {
      activeStroke = null;
      activeShapePreview = null;
      activeRuler = null;
      erasingActive = true;
      lastEraseWorld = null;
      doEraseAt(wpos.x, wpos.y);
      return;
    }

    if (t === "rect" || t === "circle" || t === "line") {
      activeShapePreview = { id: makeId(), type: t, x1: wpos.x, y1: wpos.y, x2: wpos.x, y2: wpos.y, color: brushColor(), width: brushSize(), fill: false, locked: false, layer: "draw" };
      requestRender();
      return;
    }

    if (t === "text") {
      if (pointerCaptured) {
        try { canvas.releasePointerCapture(e.pointerId); } catch {}
        pointerCaptured = false;
      }
      const raw = prompt("Text label:", "");
      if (raw == null) return;
      const text = raw.trim();
      if (!text) return;
      const x = ui.snap ? snap(wpos.x) : wpos.x;
      const y = ui.snap ? snap(wpos.y) : wpos.y;
      send("SHAPE_ADD", {
        id: makeId(),
        type: "text",
        x1: x,
        y1: y,
        x2: x,
        y2: y,
        text,
        font_size: clamp(Number(sizeEl.value || "3") * 6, 10, 48),
        color: brushColor(),
        width: 1,
        fill: false,
        locked: false,
        layer: "draw",
      });
      return;
    }

    if (t === "ruler") {
      activeRuler = { x1: wpos.x, y1: wpos.y, x2: wpos.x, y2: wpos.y };
      requestRender();
      return;
    }
  });

  canvas.addEventListener("pointermove", (e) => {
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;

    if (isPanning) {
      cam.x = panStart.camX + (e.clientX - panStart.sx);
      cam.y = panStart.camY + (e.clientY - panStart.sy);
      requestRender();
      return;
    }

    const wpos = screenToWorld(sx, sy);
    if (dragSpawn) {
      dragSpawnWorld = { x: wpos.x, y: wpos.y };
      dragSpawnOverCanvas = true;
      requestRender();
      return;
    }
    updateHoveredToken(wpos.x, wpos.y);
    const t = tool();

    if (t === "move" && draggingTokenId) {
      const tok = state.tokens.get(draggingTokenId);
      if (!tok) return;

      const x = snap(wpos.x - dragOffset.x);
      const y = snap(wpos.y - dragOffset.y);

      tok.x = x;
      tok.y = y;
      state.tokens.set(draggingTokenId, tok);
      requestRender();

      const now = Date.now();
      if (now - lastMoveSentAt >= MOVE_SEND_INTERVAL_MS) {
        lastMoveSentAt = now;
        send("TOKEN_MOVE", { id: draggingTokenId, x, y, commit: false });
      }
      return;
    }

    if (t === "move" && draggingShapeId && shapeDragOrigin) {
      const sh = state.shapes.get(draggingShapeId);
      if (!sh) return;
      const dx = wpos.x - shapeDragOrigin.wx;
      const dy = wpos.y - shapeDragOrigin.wy;
      let x1 = shapeDragOrigin.x1 + dx;
      let y1 = shapeDragOrigin.y1 + dy;
      let x2 = shapeDragOrigin.x2 + dx;
      let y2 = shapeDragOrigin.y2 + dy;
      if (ui.snap) {
        x1 = snap(x1); y1 = snap(y1); x2 = snap(x2); y2 = snap(y2);
      }
      sh.x1 = x1; sh.y1 = y1; sh.x2 = x2; sh.y2 = y2;
      state.shapes.set(draggingShapeId, sh);
      requestRender();
      const now = Date.now();
      if (now - lastMoveSentAt >= MOVE_SEND_INTERVAL_MS) {
        lastMoveSentAt = now;
        send("SHAPE_UPDATE", { id: draggingShapeId, x1, y1, x2, y2, commit: false });
      }
      return;
    }

    if (t === "pen" && activeStroke) {
      const last = activeStroke.points[activeStroke.points.length - 1];
      const dx = wpos.x - last.x;
      const dy = wpos.y - last.y;
      if (dx * dx + dy * dy >= 2.0) {
        activeStroke.points.push({ x: wpos.x, y: wpos.y });
        requestRender();
      }
      return;
    }

    if (t === "eraser" && erasingActive && (e.buttons & 1) === 1) {
      doEraseAt(wpos.x, wpos.y);
      return;
    }

    if ((t === "rect" || t === "circle" || t === "line") && activeShapePreview) {
      activeShapePreview.x2 = wpos.x;
      activeShapePreview.y2 = wpos.y;
      requestRender();
      return;
    }

    if (t === "ruler" && activeRuler) {
      activeRuler.x2 = wpos.x;
      activeRuler.y2 = wpos.y;
      requestRender();
      return;
    }
  });

  canvas.addEventListener("pointerleave", () => {
    if (dragSpawn) {
      dragSpawnOverCanvas = false;
      requestRender();
      return;
    }
    if (hoveredTokenId !== null && !draggingTokenId) {
      hoveredTokenId = null;
      requestRender();
    }
  });

  window.addEventListener("pointermove", (e) => {
    if (!dragSpawn) return;
    const rect = canvas.getBoundingClientRect();
    const inside = e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;
    dragSpawnOverCanvas = inside;
    if (inside) {
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;
      const wpos = screenToWorld(sx, sy);
      dragSpawnWorld = { x: wpos.x, y: wpos.y };
    } else {
      dragSpawnWorld = null;
    }
    requestRender();
  });

  window.addEventListener("pointerup", () => {
    if (!dragSpawn) return;
    if (!dragSpawnOverCanvas) {
      dragSpawn = null;
      dragSpawnWorld = null;
      dragSpawnOverCanvas = false;
      requestRender();
    }
  });

  function doEraseAt(wx, wy) {
    const r = 14;
    if (lastEraseWorld) {
      const dx = wx - lastEraseWorld.x;
      const dy = wy - lastEraseWorld.y;
      if (dx * dx + dy * dy < 36) return; // require ~6 world units movement
    }
    lastEraseWorld = { x: wx, y: wy };
    const now = Date.now();
    if (now - lastEraseSentAt < ERASE_SEND_INTERVAL_MS) return;
    lastEraseSentAt = now;
    send("ERASE_AT", { x: wx, y: wy, r, erase_shapes: true });
  }

  function endPointer(e) {
    if (dragSpawn) {
      if (dragSpawnWorld && dragSpawnOverCanvas) {
        spawnPackToken(dragSpawn, snap(dragSpawnWorld.x), snap(dragSpawnWorld.y));
      }
      dragSpawn = null;
      dragSpawnWorld = null;
      dragSpawnOverCanvas = false;
      if (pointerCaptured) {
        try { canvas.releasePointerCapture(e.pointerId); } catch {}
        pointerCaptured = false;
      }
      requestRender();
      return;
    }

    isPanning = false;
    const t = tool();
    const movedTokenId = draggingTokenId;
    const movedShapeId = draggingShapeId;
    draggingTokenId = null;
    draggingShapeId = null;

    if (t === "move" && movedTokenId) {
      const tok = state.tokens.get(movedTokenId);
      if (tok) {
        send("TOKEN_MOVE", { id: movedTokenId, x: tok.x, y: tok.y, commit: true });
      }
    }
    if (t === "move" && movedShapeId) {
      const sh = state.shapes.get(movedShapeId);
      if (sh) {
        send("SHAPE_UPDATE", { id: movedShapeId, x1: sh.x1, y1: sh.y1, x2: sh.x2, y2: sh.y2, commit: true });
      }
      shapeDragOrigin = null;
    }

    if (t === "eraser") {
      erasingActive = false;
      lastEraseWorld = null;
    }

    if (t === "pen" && activeStroke) {
      if (activeStroke.points.length >= 2) {
        const pts = activeStroke.points;
        const chunkSize = 12;
        if (pts.length <= chunkSize) {
          send("STROKE_ADD", {
            id: activeStroke.id,
            points: pts,
            color: activeStroke.color,
            width: activeStroke.width,
            locked: false,
            layer: "draw",
          });
        } else {
          let idx = 0;
          for (let i = 0; i < pts.length - 1; i += (chunkSize - 1)) {
            const chunk = pts.slice(i, i + chunkSize);
            if (chunk.length < 2) continue;
            send("STROKE_ADD", {
              id: `${activeStroke.id}-${idx++}`,
              points: chunk,
              color: activeStroke.color,
              width: activeStroke.width,
              locked: false,
              layer: "draw",
            });
          }
        }
      }
      activeStroke = null;
      requestRender();
    }

    if ((t === "rect" || t === "circle" || t === "line") && activeShapePreview) {
      const sh = activeShapePreview;
      const x1 = ui.snap ? snap(sh.x1) : sh.x1;
      const y1 = ui.snap ? snap(sh.y1) : sh.y1;
      const x2 = ui.snap ? snap(sh.x2) : sh.x2;
      const y2 = ui.snap ? snap(sh.y2) : sh.y2;

      send("SHAPE_ADD", {
        id: sh.id,
        type: sh.type,
        x1, y1, x2, y2,
        color: sh.color,
        width: sh.width,
        fill: false,
        locked: false,
        layer: "draw",
      });
      activeShapePreview = null;
      requestRender();
    }

    if (t === "ruler") {
      activeRuler = null;
      requestRender();
    }

    if (pointerCaptured) {
      try { canvas.releasePointerCapture(e.pointerId); } catch {}
      pointerCaptured = false;
    }
  }

  canvas.addEventListener("pointerup", endPointer);
  canvas.addEventListener("pointercancel", endPointer);
  window.addEventListener("beforeunload", () => {
    if (!online) saveOfflineStateNow();
  });
</script>
</body>
</html>
